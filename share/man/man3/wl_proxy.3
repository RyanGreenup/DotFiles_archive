.TH "wl_proxy" 3 "Sat May 23 2020" "Version 1.18.90" "Wayland" \" -*- nroff -*-
.ad l
.nh
.SH NAME
wl_proxy \- Represents a protocol object on the client side\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <wayland\-client\-core\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "struct \fBwl_proxy\fP * \fBwl_proxy_create\fP (struct \fBwl_proxy\fP *factory, const struct \fBwl_interface\fP *interface)"
.br
.ti -1c
.RI "void \fBwl_proxy_destroy\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "int \fBwl_proxy_add_listener\fP (struct \fBwl_proxy\fP *proxy, void(**implementation)(void), void *data)"
.br
.ti -1c
.RI "const void * \fBwl_proxy_get_listener\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "int \fBwl_proxy_add_dispatcher\fP (struct \fBwl_proxy\fP *proxy, \fBwl_dispatcher_func_t\fP dispatcher, const void *implementation, void *data)"
.br
.ti -1c
.RI "struct \fBwl_proxy\fP * \fBwl_proxy_marshal_array_constructor\fP (struct \fBwl_proxy\fP *proxy, uint32_t opcode, union \fBwl_argument\fP *args, const struct \fBwl_interface\fP *interface)"
.br
.ti -1c
.RI "struct \fBwl_proxy\fP * \fBwl_proxy_marshal_array_constructor_versioned\fP (struct \fBwl_proxy\fP *proxy, uint32_t opcode, union \fBwl_argument\fP *args, const struct \fBwl_interface\fP *interface, uint32_t version)"
.br
.ti -1c
.RI "void \fBwl_proxy_marshal\fP (struct \fBwl_proxy\fP *proxy, uint32_t opcode,\&.\&.\&.)"
.br
.ti -1c
.RI "struct \fBwl_proxy\fP * \fBwl_proxy_marshal_constructor\fP (struct \fBwl_proxy\fP *proxy, uint32_t opcode, const struct \fBwl_interface\fP *interface,\&.\&.\&.)"
.br
.ti -1c
.RI "struct \fBwl_proxy\fP * \fBwl_proxy_marshal_constructor_versioned\fP (struct \fBwl_proxy\fP *proxy, uint32_t opcode, const struct \fBwl_interface\fP *interface, uint32_t version,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBwl_proxy_marshal_array\fP (struct \fBwl_proxy\fP *proxy, uint32_t opcode, union \fBwl_argument\fP *args)"
.br
.ti -1c
.RI "void \fBwl_proxy_set_user_data\fP (struct \fBwl_proxy\fP *proxy, void *user_data)"
.br
.ti -1c
.RI "void * \fBwl_proxy_get_user_data\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "uint32_t \fBwl_proxy_get_version\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "uint32_t \fBwl_proxy_get_id\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "void \fBwl_proxy_set_tag\fP (struct \fBwl_proxy\fP *proxy, const char *const *tag)"
.br
.ti -1c
.RI "const char *const * \fBwl_proxy_get_tag\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "const char * \fBwl_proxy_get_class\fP (struct \fBwl_proxy\fP *proxy)"
.br
.ti -1c
.RI "void \fBwl_proxy_set_queue\fP (struct \fBwl_proxy\fP *proxy, struct \fBwl_event_queue\fP *queue)"
.br
.ti -1c
.RI "void * \fBwl_proxy_create_wrapper\fP (void *proxy)"
.br
.ti -1c
.RI "void \fBwl_proxy_wrapper_destroy\fP (void *proxy_wrapper)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Represents a protocol object on the client side\&. 

A \fBwl_proxy\fP acts as a client side proxy to an object existing in the compositor\&. The proxy is responsible for converting requests made by the clients with \fBwl_proxy_marshal()\fP into Wayland's wire format\&. Events coming from the compositor are also handled by the proxy, which will in turn call the handler set with \fBwl_proxy_add_listener()\fP\&.
.PP
\fBNote:\fP
.RS 4
With the exception of function \fBwl_proxy_set_queue()\fP, functions accessing a \fBwl_proxy\fP are not normally used by client code\&. Clients should normally use the higher level interface generated by the scanner to interact with compositor objects\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "int wl_proxy_add_dispatcher (struct \fBwl_proxy\fP * proxy, \fBwl_dispatcher_func_t\fP dispatcher, const void * implementation, void * data)"
Set a proxy's listener (with dispatcher)
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIdispatcher\fP The dispatcher to be used for this proxy 
.br
\fIimplementation\fP The dispatcher-specific listener implementation 
.br
\fIdata\fP User data to be associated with the proxy 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or -1 on failure
.RE
.PP
Set proxy's listener to use \fCdispatcher_func\fP as its dispatcher and \fCdispatcher_data\fP as its dispatcher-specific implementation and its user data to \fCdata\fP\&. If a listener has already been set, this function fails and nothing is changed\&.
.PP
The exact details of dispatcher_data depend on the dispatcher used\&. This function is intended to be used by language bindings, not user code\&.
.PP
\fCproxy\fP must not be a proxy wrapper\&. 
.SS "int wl_proxy_add_listener (struct \fBwl_proxy\fP * proxy, void(**)(void) implementation, void * data)"
Set a proxy's listener
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIimplementation\fP The listener to be added to proxy 
.br
\fIdata\fP User data to be associated with the proxy 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or -1 on failure
.RE
.PP
Set proxy's listener to \fCimplementation\fP and its user data to \fCdata\fP\&. If a listener has already been set, this function fails and nothing is changed\&.
.PP
\fCimplementation\fP is a vector of function pointers\&. For an opcode \fCn\fP, \fCimplementation\fP[n] should point to the handler of \fCn\fP for the given object\&.
.PP
\fCproxy\fP must not be a proxy wrapper\&. 
.SS "struct \fBwl_proxy\fP * wl_proxy_create (struct \fBwl_proxy\fP * factory, const struct \fBwl_interface\fP * interface)"
Create a proxy object with a given interface
.PP
\fBParameters:\fP
.RS 4
\fIfactory\fP Factory proxy object 
.br
\fIinterface\fP Interface the proxy object should use 
.RE
.PP
\fBReturns:\fP
.RS 4
A newly allocated proxy object or NULL on failure
.RE
.PP
This function creates a new proxy object with the supplied interface\&. The proxy object will have an id assigned from the client id space\&. The id should be created on the compositor side by sending an appropriate request with \fBwl_proxy_marshal()\fP\&.
.PP
The proxy will inherit the display and event queue of the factory object\&.
.PP
\fBNote:\fP
.RS 4
This should not normally be used by non-generated code\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_display\fP, \fBwl_event_queue\fP, \fBwl_proxy_marshal()\fP 
.RE
.PP

.SS "void * wl_proxy_create_wrapper (void * proxy)"
Create a proxy wrapper for making queue assignments thread-safe
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object to be wrapped 
.RE
.PP
\fBReturns:\fP
.RS 4
A proxy wrapper for the given proxy or NULL on failure
.RE
.PP
A proxy wrapper is type of 'struct \fBwl_proxy\fP' instance that can be used when sending requests instead of using the original proxy\&. A proxy wrapper does not have an implementation or dispatcher, and events received on the object is still emitted on the original proxy\&. Trying to set an implementation or dispatcher will have no effect but result in a warning being logged\&.
.PP
Setting the proxy queue of the proxy wrapper will make new objects created using the proxy wrapper use the set proxy queue\&. Even though there is no implementation nor dispatcher, the proxy queue can be changed\&. This will affect the default queue of new objects created by requests sent via the proxy wrapper\&.
.PP
A proxy wrapper can only be destroyed using \fBwl_proxy_wrapper_destroy()\fP\&.
.PP
A proxy wrapper must be destroyed before the proxy it was created from\&.
.PP
If a user reads and dispatches events on more than one thread, it is necessary to use a proxy wrapper when sending requests on objects when the intention is that a newly created proxy is to use a proxy queue different from the proxy the request was sent on, as creating the new proxy and then setting the queue is not thread safe\&.
.PP
For example, a module that runs using its own proxy queue that needs to do display roundtrip must wrap the \fBwl_display\fP proxy object before sending the wl_display\&.sync request\&. For example:
.PP
.PP
.nf
struct wl_event_queue *queue = \&.\&.\&.;
struct wl_display *wrapped_display;
struct wl_callback *callback;

wrapped_display = wl_proxy_create_wrapper(display);
wl_proxy_set_queue((struct wl_proxy *) wrapped_display, queue);
callback = wl_display_sync(wrapped_display);
wl_proxy_wrapper_destroy(wrapped_display);
wl_callback_add_listener(callback, \&.\&.\&.);
.fi
.PP
 
.SS "void wl_proxy_destroy (struct \fBwl_proxy\fP * proxy)"
Destroy a proxy object
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy to be destroyed
.RE
.PP
\fCproxy\fP must not be a proxy wrapper\&. 
.SS "const char * wl_proxy_get_class (struct \fBwl_proxy\fP * proxy)"
Get the interface name (class) of a proxy object
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.RE
.PP
\fBReturns:\fP
.RS 4
The interface name of the object associated with the proxy 
.RE
.PP

.SS "uint32_t wl_proxy_get_id (struct \fBwl_proxy\fP * proxy)"
Get the id of a proxy object
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.RE
.PP
\fBReturns:\fP
.RS 4
The id the object associated with the proxy 
.RE
.PP

.SS "const void * wl_proxy_get_listener (struct \fBwl_proxy\fP * proxy)"
Get a proxy's listener
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.RE
.PP
\fBReturns:\fP
.RS 4
The address of the proxy's listener or NULL if no listener is set
.RE
.PP
Gets the address to the proxy's listener; which is the listener set with \fBwl_proxy_add_listener\fP\&.
.PP
This function is useful in clients with multiple listeners on the same interface to allow the identification of which code to execute\&. 
.SS "const char *const  * wl_proxy_get_tag (struct \fBwl_proxy\fP * proxy)"
Get the tag of a proxy object
.PP
See wl_proxy_set_tag for details\&.
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object
.RE
.PP
\fBSince:\fP
.RS 4
1\&.17\&.90 
.RE
.PP

.SS "void * wl_proxy_get_user_data (struct \fBwl_proxy\fP * proxy)"
Get the user data associated with a proxy
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.RE
.PP
\fBReturns:\fP
.RS 4
The user data associated with proxy 
.RE
.PP

.SS "uint32_t wl_proxy_get_version (struct \fBwl_proxy\fP * proxy)"
Get the protocol object version of a proxy object
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.RE
.PP
\fBReturns:\fP
.RS 4
The protocol object version of the proxy or 0
.RE
.PP
Gets the protocol object version of a proxy object, or 0 if the proxy was created with unversioned API\&.
.PP
A returned value of 0 means that no version information is available, so the caller must make safe assumptions about the object's real version\&.
.PP
\fBwl_display\fP's version will always return 0\&. 
.SS "void wl_proxy_marshal (struct \fBwl_proxy\fP * proxy, uint32_t opcode,  \&.\&.\&.)"
Prepare a request to be sent to the compositor
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIopcode\fP Opcode of the request to be sent 
.br
\fI\&.\&.\&.\fP Extra arguments for the given request
.RE
.PP
This function is similar to \fBwl_proxy_marshal_constructor()\fP, except it doesn't create proxies for new-id arguments\&.
.PP
\fBNote:\fP
.RS 4
This should not normally be used by non-generated code\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_proxy_create()\fP 
.RE
.PP

.SS "void wl_proxy_marshal_array (struct \fBwl_proxy\fP * proxy, uint32_t opcode, union \fBwl_argument\fP * args)"
Prepare a request to be sent to the compositor
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIopcode\fP Opcode of the request to be sent 
.br
\fIargs\fP Extra arguments for the given request
.RE
.PP
This function is similar to \fBwl_proxy_marshal_array_constructor()\fP, except it doesn't create proxies for new-id arguments\&.
.PP
\fBNote:\fP
.RS 4
This is intended to be used by language bindings and not in non-generated code\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_proxy_marshal()\fP 
.RE
.PP

.SS "struct \fBwl_proxy\fP * wl_proxy_marshal_array_constructor (struct \fBwl_proxy\fP * proxy, uint32_t opcode, union \fBwl_argument\fP * args, const struct \fBwl_interface\fP * interface)"
Prepare a request to be sent to the compositor
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIopcode\fP Opcode of the request to be sent 
.br
\fIargs\fP Extra arguments for the given request 
.br
\fIinterface\fP The interface to use for the new proxy
.RE
.PP
This function translates a request given an opcode, an interface and a \fBwl_argument\fP array to the wire format and writes it to the connection buffer\&.
.PP
For new-id arguments, this function will allocate a new \fBwl_proxy\fP and send the ID to the server\&. The new \fBwl_proxy\fP will be returned on success or NULL on error with errno set accordingly\&. The newly created proxy will inherit their version from their parent\&.
.PP
\fBNote:\fP
.RS 4
This is intended to be used by language bindings and not in non-generated code\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_proxy_marshal()\fP 
.RE
.PP

.SS "struct \fBwl_proxy\fP * wl_proxy_marshal_array_constructor_versioned (struct \fBwl_proxy\fP * proxy, uint32_t opcode, union \fBwl_argument\fP * args, const struct \fBwl_interface\fP * interface, uint32_t version)"
Prepare a request to be sent to the compositor
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIopcode\fP Opcode of the request to be sent 
.br
\fIargs\fP Extra arguments for the given request 
.br
\fIinterface\fP The interface to use for the new proxy 
.br
\fIversion\fP The protocol object version for the new proxy
.RE
.PP
Translates the request given by opcode and the extra arguments into the wire format and write it to the connection buffer\&. This version takes an array of the union type \fBwl_argument\fP\&.
.PP
For new-id arguments, this function will allocate a new \fBwl_proxy\fP and send the ID to the server\&. The new \fBwl_proxy\fP will be returned on success or NULL on error with errno set accordingly\&. The newly created proxy will have the version specified\&.
.PP
\fBNote:\fP
.RS 4
This is intended to be used by language bindings and not in non-generated code\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_proxy_marshal()\fP 
.RE
.PP

.SS "struct \fBwl_proxy\fP * wl_proxy_marshal_constructor (struct \fBwl_proxy\fP * proxy, uint32_t opcode, const struct \fBwl_interface\fP * interface,  \&.\&.\&.)"
Prepare a request to be sent to the compositor
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIopcode\fP Opcode of the request to be sent 
.br
\fIinterface\fP The interface to use for the new proxy 
.br
\fI\&.\&.\&.\fP Extra arguments for the given request 
.RE
.PP
\fBReturns:\fP
.RS 4
A new \fBwl_proxy\fP for the new_id argument or NULL on error
.RE
.PP
This function translates a request given an opcode, an interface and extra arguments to the wire format and writes it to the connection buffer\&. The types of the extra arguments must correspond to the argument types of the method associated with the opcode in the interface\&.
.PP
For new-id arguments, this function will allocate a new \fBwl_proxy\fP and send the ID to the server\&. The new \fBwl_proxy\fP will be returned on success or NULL on error with errno set accordingly\&. The newly created proxy will inherit their version from their parent\&.
.PP
\fBNote:\fP
.RS 4
This should not normally be used by non-generated code\&. 
.RE
.PP

.SS "struct \fBwl_proxy\fP * wl_proxy_marshal_constructor_versioned (struct \fBwl_proxy\fP * proxy, uint32_t opcode, const struct \fBwl_interface\fP * interface, uint32_t version,  \&.\&.\&.)"
Prepare a request to be sent to the compositor
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIopcode\fP Opcode of the request to be sent 
.br
\fIinterface\fP The interface to use for the new proxy 
.br
\fIversion\fP The protocol object version of the new proxy 
.br
\fI\&.\&.\&.\fP Extra arguments for the given request 
.RE
.PP
\fBReturns:\fP
.RS 4
A new \fBwl_proxy\fP for the new_id argument or NULL on error
.RE
.PP
Translates the request given by opcode and the extra arguments into the wire format and write it to the connection buffer\&.
.PP
For new-id arguments, this function will allocate a new \fBwl_proxy\fP and send the ID to the server\&. The new \fBwl_proxy\fP will be returned on success or NULL on error with errno set accordingly\&. The newly created proxy will have the version specified\&.
.PP
\fBNote:\fP
.RS 4
This should not normally be used by non-generated code\&. 
.RE
.PP

.SS "void wl_proxy_set_queue (struct \fBwl_proxy\fP * proxy, struct \fBwl_event_queue\fP * queue)"
Assign a proxy to an event queue
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIqueue\fP The event queue that will handle this proxy or NULL
.RE
.PP
Assign proxy to event queue\&. Events coming from \fCproxy\fP will be queued in \fCqueue\fP from now\&. If queue is NULL, then the display's default queue is set to the proxy\&.
.PP
\fBNote:\fP
.RS 4
By default, the queue set in proxy is the one inherited from parent\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_dispatch_queue()\fP 
.RE
.PP

.SS "void wl_proxy_set_tag (struct \fBwl_proxy\fP * proxy, const char *const * tag)"
Set the tag of a proxy object
.PP
A toolkit or application can set a unique tag on a proxy in order to identify whether an object is managed by itself or some external part\&.
.PP
To create a tag, the recommended way is to define a statically allocated constant char array containing some descriptive string\&. The tag will be the pointer to the non-const pointer to the beginning of the array\&.
.PP
For example, to define and set a tag on a surface managed by a certain subsystem: 
.PP
.nf
    static const char *my_tag = "my tag";

    wl_proxy_set_tag((struct wl_proxy *) surface, &my_tag);

.fi
.PP
.PP
Then, in a callback with wl_surface as an argument, in order to check whether it's a surface managed by the same subsystem\&. 
.PP
.nf
    const char * const *tag;

    tag = wl_proxy_get_tag((struct wl_proxy *) surface);
    if (tag != &my_tag)
    return;

 ...

.fi
.PP
.PP
For debugging purposes, a tag should be suitable to be included in a debug log entry, e\&.g\&. 
.PP
.nf
    const char * const *tag;

    tag = wl_proxy_get_tag((struct wl_proxy *) surface);
    printf("Got a surface with the tag %p (%s)\n",
           tag, (tag && *tag) ? *tag : "");

.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fItag\fP The tag
.RE
.PP
\fBSince:\fP
.RS 4
1\&.17\&.90 
.RE
.PP

.SS "void wl_proxy_set_user_data (struct \fBwl_proxy\fP * proxy, void * user_data)"
Set the user data associated with a proxy
.PP
\fBParameters:\fP
.RS 4
\fIproxy\fP The proxy object 
.br
\fIuser_data\fP The data to be associated with proxy
.RE
.PP
Set the user data associated with \fCproxy\fP\&. When events for this proxy are received, \fCuser_data\fP will be supplied to its listener\&. 
.SS "void wl_proxy_wrapper_destroy (void * proxy_wrapper)"
Destroy a proxy wrapper 
.PP
\fBParameters:\fP
.RS 4
\fIproxy_wrapper\fP The proxy wrapper to be destroyed 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Wayland from the source code\&.
