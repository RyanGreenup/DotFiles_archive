<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Appendix C. Server API</title><link rel="stylesheet" type="text/css" href="css/default.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Wayland"><link rel="up" href="index.html" title="Wayland"><link rel="prev" href="apb.html" title="Appendix B. Client API"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix C. Server API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="apb.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="sect-Library-Server"></a>Appendix C. Server API</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="apc.html#idm4767">Introduction</a></span></dt><dt><span class="section"><a href="apc.html#Server-unionwl__argument">wl_argument
                - 
Protocol message argument data types.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__array">wl_array
                - 
Dynamic array.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__client">wl_client</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__display">wl_display</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__event__loop">wl_event_loop
                - 
An event loop context.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__event__source">wl_event_source
                - 
An abstract event source.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__global">wl_global</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__interface">wl_interface
                - 
Protocol object interface.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__list">wl_list
                - 
Doubly-linked list.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__listener">wl_listener
                - 
A single listener for Wayland signals.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__message">wl_message
                - 
Protocol message signature.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__object">wl_object
                - 
A protocol object.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__protocol__logger">wl_protocol_logger</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__protocol__logger__message">wl_protocol_logger_message</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__resource">wl_resource</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__resource__iterator__context">wl_resource_iterator_context</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__shm__buffer">wl_shm_buffer</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__shm__pool">wl_shm_pool</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__shm__sigbus__data">wl_shm_sigbus_data</a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__signal">wl_signal
                - 
A source of a type of observable event.     </a></span></dt><dt><span class="section"><a href="apc.html#Server-structwl__socket">wl_socket</a></span></dt><dt><span class="section"><a href="apc.html#Server-Functions">Functions</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm4767"></a>Introduction</h2></div></div></div><p>
    The open-source reference implementation of Wayland protocol is
    split in two C libraries, <a class="link" href="apb.html" title="Appendix B. Client API">libwayland-client</a> and
    libwayland-server. Their main responsibility is to handle the
    Inter-process communication (<span class="emphasis"><em>IPC</em></span>) with each
    other, therefore guaranteeing the protocol objects marshaling and
    messages synchronization.
  </p><p>
    The server library is designed to work much like libwayland-client,
    although it is considerably complicated due to the server needing
    to support multiple versions of the protocol. It is best to learn
    libwayland-client first.
  </p><p>
    Each open socket to a client is represented by a <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a>.  The equvalent
    of the <a class="link" href="apb.html#Client-classwl__proxy" title="wl_proxy - Represents a protocol object on the client side.">wl_proxy</a> that
    libwayland-client uses to represent an object is <a class="link" href="apc.html#Server-structwl__resource" title="wl_resource">wl_resource</a> for
    client-created objects, and <a class="link" href="apc.html#Server-structwl__global" title="wl_global">wl_global</a> for objects
    created by the server.
  </p><p>
    Often a server is also a client for another Wayland server, and
    thus must link with both libwayland-client and libwayland-server.
    This produces some type name conflicts (such as the <a class="link" href="apb.html#Client-classwl__display" title="wl_display - Represents a connection to the compositor and acts as a proxy to the wl_display singleton object.">client wl_display</a> and
    <a class="link" href="apc.html#Server-structwl__display" title="wl_display">server wl_display</a>,
    but the duplicate-but-not-the-same types are opaque, and accessed
    only inside the correct library where it came from. Naturally that
    means that the program writer needs to always know if a pointer to
    a wl_display is for the server or client side and use the
    corresponding functions.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-unionwl__argument"></a>wl_argument
                - 
Protocol message argument data types.     </h2></div></div></div><p>This union represents all of the argument types in the Wayland protocol wire format. The protocol implementation uses <a class="link" href="apc.html#Server-unionwl__argument" title="wl_argument - Protocol message argument data types.">wl_argument</a> within its marshalling machinery for dispatching messages between a client and a compositor.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> 

  See also: <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> 

  See also: Wire Format 
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__array"></a>wl_array
                - 
Dynamic array.     </h2></div></div></div><p>A <a class="link" href="apc.html#Server-structwl__array" title="wl_array - Dynamic array.">wl_array</a> is a dynamic array that can only grow until released. It is intended for relatively small allocations whose size is variable or not known in advance. While construction of a <a class="link" href="apc.html#Server-structwl__array" title="wl_array - Dynamic array.">wl_array</a> does not require all elements to be of the same size, <a class="link" href="apc.html#Server-structwl__array_1ab050f7375dcae916506142763080ed80">wl_array_for_each()</a> does require all elements to have the same type and size. </p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__array_1ae246c66cbd633063e2649c503d764d3f"></a><span class="term">size
            - 
Array size.         </span></dt><dd><pre class="synopsis">size_t wl_array::size</pre></dd><dt><a name="Server-structwl__array_1a4b33519c8f628d650631ebecee45b771"></a><span class="term">alloc
            - 
Allocated space.         </span></dt><dd><pre class="synopsis">size_t wl_array::alloc</pre></dd><dt><a name="Server-structwl__array_1af20153b7fcf63135eea72dd5d9e8b87b"></a><span class="term">data
            - 
Array data.         </span></dt><dd><pre class="synopsis">void* wl_array::data</pre></dd><dt><a name="Server-structwl__array_1ada9b770427b901be34eaf3683cf04d5a"></a><span class="term">wl_array_init
            - 
Initializes the array.         </span></dt><dd><pre class="synopsis">void wl_array_init(struct wl_array *array)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">array</span></dt><dd>
Array to initialize </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__array_1a0e8845f61f1e1fccfce050830ed5b279"></a><span class="term">wl_array_release
            - 
Releases the array data.         </span></dt><dd><pre class="synopsis">void wl_array_release(struct wl_array *array)</pre><p><span class="emphasis"><em>Note: Leaves the array in an invalid state.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">array</span></dt><dd>
Array whose data is to be released </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__array_1a3c3d1079a20b0609f6e4914ea21c2d03"></a><span class="term">wl_array_add
            - 
Increases the size of the array by size bytes.         </span></dt><dd><pre class="synopsis">void * wl_array_add(struct wl_array *array, size_t size)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">array</span></dt><dd>
Array whose size is to be increased </dd><dt><span class="term">size</span></dt><dd>
Number of bytes to increase the size of the array by</dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A pointer to the beginning of the newly appended space, or NULL when resizing fails. </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__array_1a4de64390294de78da813dcfb16f47617"></a><span class="term">wl_array_copy
            - 
Copies the contents of source to array.         </span></dt><dd><pre class="synopsis">int wl_array_copy(struct wl_array *array, struct wl_array *source)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">array</span></dt><dd>
Destination array to copy to </dd><dt><span class="term">source</span></dt><dd>
Source array to copy from</dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 on success, or -1 on failure </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__array_1ab050f7375dcae916506142763080ed80"></a><span class="term">wl_array_for_each
            - 
Iterates over an array.         </span></dt><dd><pre class="synopsis"></pre><p>This macro expresses a for-each iterator for <a class="link" href="apc.html#Server-structwl__array" title="wl_array - Dynamic array.">wl_array</a>. It assigns each element in the array to pos, which can then be referenced in a trailing code block. pos must be a pointer to the array element type, and all array elements must be of the same type and size.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">pos</span></dt><dd>
Cursor that each array element will be assigned to </dd><dt><span class="term">array</span></dt><dd>
Array to iterate over</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__list_1a449407fe3c8f273e38bc2253093cb6fb">wl_list_for_each()</a> 
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__client"></a>wl_client</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__client_1a6a045ad15d6ca216c4da41ba67c9ef4a"></a><span class="term">wl_client_flush
            - 
Flush pending events to the client.         </span></dt><dd><pre class="synopsis">void wl_client_flush(struct wl_client *client)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object</dd></dl></div><p>
Events sent to clients are queued in a buffer and written to the socket later - typically when the compositor has handled all requests and goes back to block in the event loop. This function flushes all queued up events for a client immediately. </p></dd><dt><a name="Server-structwl__client_1a9b2abda633c67a4cd06ea5d9be0482f3"></a><span class="term">wl_client_get_display
            - 
Get the display object for the given client.         </span></dt><dd><pre class="synopsis">struct wl_display * wl_client_get_display(struct wl_client *client)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The display object the client is associated with. </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__client_1a82a97cb3a66c1c56826a09a7b42453d9"></a><span class="term">wl_client_get_credentials
            - 
Return Unix credentials for the client.         </span></dt><dd><pre class="synopsis">void wl_client_get_credentials(struct wl_client *client, pid_t *pid, uid_t *uid, gid_t *gid)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The display object </dd><dt><span class="term">pid</span></dt><dd>
Returns the process ID </dd><dt><span class="term">uid</span></dt><dd>
Returns the user ID </dd><dt><span class="term">gid</span></dt><dd>
Returns the group ID</dd></dl></div><p>
This function returns the process ID, the user ID and the group ID for the given client. The credentials come from getsockopt() with SO_PEERCRED, on the client socket fd. All the pointers can be NULL, if the caller is not interested in a particular ID.</p><p>Be aware that for clients that a compositor forks and execs and then connects using socketpair(), this function will return the credentials for the compositor. The credentials for the socketpair are set at creation time in the compositor. </p></dd><dt><a name="Server-structwl__client_1ad5a94921b39efad0985632e865479ca2"></a><span class="term">wl_client_get_fd
            - 
Get the file descriptor for the client.         </span></dt><dd><pre class="synopsis">int wl_client_get_fd(struct wl_client *client)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The display object </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The file descriptor to use for the connection</dd></dl></div><p>
This function returns the file descriptor for the given client.</p><p>Be sure to use the file descriptor from the client for inspection only. If the caller does anything to the file descriptor that changes its state, it will likely cause problems.</p><p>See also <a class="link" href="apc.html#Server-structwl__client_1a82a97cb3a66c1c56826a09a7b42453d9">wl_client_get_credentials()</a>. It is recommended that you evaluate whether <a class="link" href="apc.html#Server-structwl__client_1a82a97cb3a66c1c56826a09a7b42453d9">wl_client_get_credentials()</a> can be applied to your use case instead of this function.</p><p>If you would like to distinguish just between the client and the compositor itself from the client's request, it can be done by getting the client credentials and by checking the PID of the client and the compositor's PID. Regarding the case in which the socketpair() is being used, you need to be careful. Please note the documentation for <a class="link" href="apc.html#Server-structwl__client_1a82a97cb3a66c1c56826a09a7b42453d9">wl_client_get_credentials()</a>.</p><p>This function can be used for a compositor to validate a request from a client if there are additional information provided from the client's file descriptor. For instance, suppose you can get the security contexts from the client's file descriptor. The compositor can validate the client's request with the contexts and make a decision whether it permits or deny it. </p></dd><dt><a name="Server-structwl__client_1ab9d04dffa9409db43154230c64bc1f84"></a><span class="term">wl_client_get_object
            - 
Look up an object in the client name space.         </span></dt><dd><pre class="synopsis">struct wl_resource * wl_client_get_object(struct wl_client *client, uint32_t id)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object </dd><dt><span class="term">id</span></dt><dd>
The object id </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The object or NULL if there is not object for the given ID</dd></dl></div><p>
This looks up an object in the client object name space by its object ID. </p></dd><dt><a name="Server-structwl__client_1a5566e9729f5231e1314c48b9fa1de761"></a><span class="term">wl_client_post_implementation_error
            - 
Report an internal server error.         </span></dt><dd><pre class="synopsis">void wl_client_post_implementation_error(struct wl_client *client, char const *msg,...)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object </dd><dt><span class="term">msg</span></dt><dd>
A printf-style format string </dd><dt><span class="term">...</span></dt><dd>
Format string arguments</dd></dl></div><p>
Report an unspecified internal implementation error and disconnect the client. </p></dd><dt><a name="Server-structwl__client_1ade7bddc335d60cb95f9d1bd4fb60d25b"></a><span class="term">wl_client_get_link
            - 
Get the link by which a client is inserted in the client list.         </span></dt><dd><pre class="synopsis">struct wl_list * wl_client_get_link(struct wl_client *client)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-wayland-server-core_8h_1af1e9ad8dd32ea89265936930cd173ec5">wl_client_for_each()</a> 

  See also: <a class="link" href="apc.html#Server-structwl__display_1a99b9c187d88633fa5ba86d1424f06d7f">wl_display_get_client_list()</a> 

  See also: <a class="link" href="apc.html#Server-structwl__client_1aec831218471327f37b4e1f11b571545d">wl_client_from_link()</a> 
</p></dd><dt><a name="Server-structwl__client_1aec831218471327f37b4e1f11b571545d"></a><span class="term">wl_client_from_link
            - 
Get a wl_client by its link.         </span></dt><dd><pre class="synopsis">struct wl_client * wl_client_from_link(struct wl_list *link)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">link</span></dt><dd>
The link of a <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a></dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-wayland-server-core_8h_1af1e9ad8dd32ea89265936930cd173ec5">wl_client_for_each()</a> 

  See also: <a class="link" href="apc.html#Server-structwl__display_1a99b9c187d88633fa5ba86d1424f06d7f">wl_display_get_client_list()</a> 

  See also: <a class="link" href="apc.html#Server-structwl__client_1ade7bddc335d60cb95f9d1bd4fb60d25b">wl_client_get_link()</a> 
</p></dd><dt><a name="Server-structwl__client_1a62a52be27947e43ce7884a68759d1b4e"></a><span class="term">wl_client_add_resource_created_listener
            - 
Add a listener for the client's resource creation signal.         </span></dt><dd><pre class="synopsis">void wl_client_add_resource_created_listener(struct wl_client *client, struct wl_listener *listener)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object </dd><dt><span class="term">listener</span></dt><dd>
The listener to be added</dd></dl></div><p>
When a new resource is created for this client the listener will be notified, carrying the new resource as the data argument. </p></dd><dt><a name="Server-structwl__client_1a4a0a6bb48f63ed80ab4575fda4c5d01a"></a><span class="term">wl_client_for_each_resource
            - 
Iterate over all the resources of a client.         </span></dt><dd><pre class="synopsis">void wl_client_for_each_resource(struct wl_client *client, wl_client_for_each_resource_iterator_func_t iterator, void *user_data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object </dd><dt><span class="term">iterator</span></dt><dd>
The iterator function </dd><dt><span class="term">user_data</span></dt><dd>
The user data pointer</dd></dl></div><p>
The function pointed by iterator will be called for each resource owned by the client. The user_data will be passed as the second argument of the iterator function. If the iterator function returns WL_ITERATOR_CONTINUE the iteration will continue, if it returns WL_ITERATOR_STOP it will stop.</p><p>Creating and destroying resources while iterating is safe, but new resources may or may not be picked up by the iterator.</p><p>
  See also: <a class="link" href="apc.html#Server-wayland-util_8h_1adb093d005a4b7e04111b7e385349cf23">wl_iterator_result</a> 
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__display"></a>wl_display</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__display_1aa2436b6a0b56cd65d8f6e33b76cd292c"></a><span class="term">wl_client_create
            - 
Create a client for the given file descriptor.         </span></dt><dd><pre class="synopsis">struct wl_client * wl_client_create(struct wl_display *display, int fd)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object </dd><dt><span class="term">fd</span></dt><dd>
The file descriptor for the socket to the client </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The new client object or NULL on failure.</dd></dl></div><p>
Given a file descriptor corresponding to one end of a socket, this function will create a <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a> struct and add the new client to the compositors client list. At that point, the client is initialized and ready to run, as if the client had connected to the servers listening socket. When the client eventually sends requests to the compositor, the <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a> argument to the request handler will be the <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a> returned from this function.</p><p>The other end of the socket can be passed to wl_display_connect_to_fd() on the client side or used with the WAYLAND_SOCKET environment variable on the client side.</p><p>Listeners added with <a class="link" href="apc.html#Server-wayland-server_8c_1a8c1cdf513c91fa498c4d9259eae3ed71">wl_display_add_client_created_listener()</a> will be notified by this function after the client is fully constructed.</p><p>On failure this function sets errno accordingly and returns NULL. </p></dd><dt><a name="Server-structwl__display_1ac3dd9a1294b2b6103228a55e08709e9f"></a><span class="term">wl_display_create
            - 
Create Wayland display object.         </span></dt><dd><pre class="synopsis">struct wl_display * wl_display_create(void)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The Wayland display object. Null if failed to create</dd></dl></div><p>
This creates the <a class="link" href="apc.html#Server-structwl__display" title="wl_display">wl_display</a> object. </p></dd><dt><a name="Server-structwl__display_1acd9ad2e1ca3ffb0ba0f1b77ae616f8ee"></a><span class="term">wl_display_destroy
            - 
Destroy Wayland display object.         </span></dt><dd><pre class="synopsis">void wl_display_destroy(struct wl_display *display)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The Wayland display object which should be destroyed. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>None.</dd></dl></div><p>
This function emits the <a class="link" href="apc.html#Server-structwl__display" title="wl_display">wl_display</a> destroy signal, releases all the sockets added to this display, free's all the globals associated with this display, free's memory of additional shared memory formats and destroy the display object.</p><p>
  See also: <a class="link" href="apc.html#Server-wayland-server-core_8h_1a9ea24547f07538f2a326c42c7793b937">wl_display_add_destroy_listener</a> 
</p></dd><dt><a name="Server-structwl__display_1a3905b9734d8bb84f2c851bb4abbc52f8"></a><span class="term">wl_display_set_global_filter
            - 
Set a filter function for global objects.         </span></dt><dd><pre class="synopsis">void wl_display_set_global_filter(struct wl_display *display, wl_display_global_filter_func_t filter, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The Wayland display object. </dd><dt><span class="term">filter</span></dt><dd>
The global filter funtion. </dd><dt><span class="term">data</span></dt><dd>
User data to be associated with the global filter. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>None.</dd></dl></div><p>
Set a filter for the <a class="link" href="apc.html#Server-structwl__display" title="wl_display">wl_display</a> to advertise or hide global objects to clients. The set filter will be used during <a class="link" href="apc.html#Server-structwl__global" title="wl_global">wl_global</a> advertisment to determine whether a global object should be advertised to a given client, and during <a class="link" href="apc.html#Server-structwl__global" title="wl_global">wl_global</a> binding to determine whether a given client should be allowed to bind to a global.</p><p>Clients that try to bind to a global that was filtered out will have an error raised.</p><p>Setting the filter NULL will result in all globals being advertised to all clients. The default is no filter. </p></dd><dt><a name="Server-structwl__display_1a43f04f76ea1457edcf37c95de68b29ef"></a><span class="term">wl_display_get_serial
            - 
Get the current serial number.         </span></dt><dd><pre class="synopsis">uint32_t wl_display_get_serial(struct wl_display *display)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object</dd></dl></div><p>
This function returns the most recent serial number, but does not increment it. </p></dd><dt><a name="Server-structwl__display_1a145f7d3e4b41fc9014c11bf01bd7eb4f"></a><span class="term">wl_display_next_serial
            - 
Get the next serial number.         </span></dt><dd><pre class="synopsis">uint32_t wl_display_next_serial(struct wl_display *display)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object</dd></dl></div><p>
This function increments the display serial number and returns the new value. </p></dd><dt><a name="Server-structwl__display_1ab50365739904f91579a66f4b054a3ecb"></a><span class="term">wl_display_destroy_clients
            - 
Destroy all clients connected to the display.         </span></dt><dd><pre class="synopsis">void wl_display_destroy_clients(struct wl_display *display)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object</dd></dl></div><p>
This function should be called right before <a class="link" href="apc.html#Server-structwl__display_1acd9ad2e1ca3ffb0ba0f1b77ae616f8ee">wl_display_destroy()</a> to ensure all client resources are closed properly. Destroying a client from within <a class="link" href="apc.html#Server-structwl__display_1ab50365739904f91579a66f4b054a3ecb">wl_display_destroy_clients()</a> is safe, but creating one will leak resources and raise a warning. </p></dd><dt><a name="Server-structwl__display_1a54f1cf58cc74cd44c889b2cdf029345d"></a><span class="term">wl_display_add_socket_fd
            - 
Add a socket with an existing fd to Wayland display for the clients to connect.         </span></dt><dd><pre class="synopsis">int wl_display_add_socket_fd(struct wl_display *display, int sock_fd)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
Wayland display to which the socket should be added. </dd><dt><span class="term">sock_fd</span></dt><dd>
The existing socket file descriptor to be used </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 if success. -1 if failed.</dd></dl></div><p>
The existing socket fd must already be created, opened, and locked. The fd must be properly set to CLOEXEC and bound to a socket file with both bind() and listen() already called. </p></dd><dt><a name="Server-structwl__display_1a9fdf7264f0a3a28a75c141db252067b8"></a><span class="term">wl_display_add_socket
            - 
Add a socket to Wayland display for the clients to connect.         </span></dt><dd><pre class="synopsis">int wl_display_add_socket(struct wl_display *display, const char *name)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
Wayland display to which the socket should be added. </dd><dt><span class="term">name</span></dt><dd>
Name of the Unix socket. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 if success. -1 if failed.</dd></dl></div><p>
This adds a Unix socket to Wayland display which can be used by clients to connect to Wayland display.</p><p>If NULL is passed as name, then it would look for WAYLAND_DISPLAY env variable for the socket name. If WAYLAND_DISPLAY is not set, then default wayland-0 is used.</p><p>The Unix socket will be created in the directory pointed to by environment variable XDG_RUNTIME_DIR. If XDG_RUNTIME_DIR is not set, then this function fails and returns -1.</p><p>The length of socket path, i.e., the path set in XDG_RUNTIME_DIR and the socket name, must not exceed the maximum length of a Unix socket path. The function also fails if the user do not have write permission in the XDG_RUNTIME_DIR path or if the socket name is already in use. </p></dd><dt><a name="Server-structwl__display_1a4dc118c686e362aba0b3c6c8874efc3d"></a><span class="term">wl_display_add_protocol_logger
            - 
Adds a new protocol logger.         </span></dt><dd><pre class="synopsis">struct wl_protocol_logger * wl_display_add_protocol_logger(struct wl_display *display, wl_protocol_logger_func_t func, void *user_data)</pre><p>When a new protocol message arrives or is sent from the server all the protocol logger functions will be called, carrying the user_data pointer, the type of the message (request or event) and the actual message. The lifetime of the messages passed to the logger function ends when they return so the messages cannot be stored and accessed later.</p><p>errno is set on error.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object </dd><dt><span class="term">func</span></dt><dd>
The function to call to log a new protocol message </dd><dt><span class="term">user_data</span></dt><dd>
The user data pointer to pass to func </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The protol logger object on success, NULL on failure.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__protocol__logger_1ac5bfbf098cbecb788190bc12e3becad7">wl_protocol_logger_destroy</a> 
</p></dd><dt><a name="Server-structwl__display_1ad806e5d1f937b32f62998c44a0a16421"></a><span class="term">wl_display_add_shm_format
            - 
Add support for a wl_shm pixel format.         </span></dt><dd><pre class="synopsis">uint32_t * wl_display_add_shm_format(struct wl_display *display, uint32_t format)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object </dd><dt><span class="term">format</span></dt><dd>
The wl_shm pixel format to advertise </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A pointer to the wl_shm format that was added to the list or NULL if adding it to the list failed.</dd></dl></div><p>
Add the specified wl_shm format to the list of formats the wl_shm object advertises when a client binds to it. Adding a format to the list means that clients will know that the compositor supports this format and may use it for creating wl_shm buffers. The compositor must be able to handle the pixel format when a client requests it.</p><p>The compositor by default supports WL_SHM_FORMAT_ARGB8888 and WL_SHM_FORMAT_XRGB8888. </p></dd><dt><a name="Server-structwl__display_1a99b9c187d88633fa5ba86d1424f06d7f"></a><span class="term">wl_display_get_client_list
            - 
Get the list of currently connected clients.         </span></dt><dd><pre class="synopsis">struct wl_list * wl_display_get_client_list(struct wl_display *display)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object</dd></dl></div><p>
This function returns a pointer to the list of clients currently connected to the display. You can iterate on the list by using the wl_client_for_each macro. The returned value is valid for the lifetime of the display. You must not modify the returned list, but only access it.</p><p>
  See also: <a class="link" href="apc.html#Server-wayland-server-core_8h_1af1e9ad8dd32ea89265936930cd173ec5">wl_client_for_each()</a> 

  See also: <a class="link" href="apc.html#Server-structwl__client_1ade7bddc335d60cb95f9d1bd4fb60d25b">wl_client_get_link()</a> 

  See also: <a class="link" href="apc.html#Server-structwl__client_1aec831218471327f37b4e1f11b571545d">wl_client_from_link()</a> 
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__event__loop"></a>wl_event_loop
                - 
An event loop context.     </h2></div></div></div><p>Usually you create an event loop context, add sources to it, and call <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> in a loop to process events.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__event__source" title="wl_event_source - An abstract event source.">wl_event_source</a> 
</p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__event__loop_1afb0958142b950045cd91011c71706979"></a><span class="term">wl_event_loop_create
            - 
Create a new event loop context.         </span></dt><dd><pre class="synopsis">struct wl_event_loop * wl_event_loop_create(void)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A new event loop context object.</dd></dl></div><p>
This creates a new event loop context. Initially this context is empty. Event sources need to be explicitly added to it.</p><p>Normally the event loop is run by calling <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> in a loop until the program terminates. Alternatively, an event loop can be embedded in another event loop by its file descriptor, see <a class="link" href="apc.html#Server-structwl__event__loop_1a58c8aa06a2d240a49a95a91eddcba8e5">wl_event_loop_get_fd()</a>. </p></dd><dt><a name="Server-structwl__event__loop_1ad50f13e2c738e68f7576757aa862513a"></a><span class="term">wl_event_loop_destroy
            - 
Destroy an event loop context.         </span></dt><dd><pre class="synopsis">void wl_event_loop_destroy(struct wl_event_loop *loop)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop to be destroyed.</dd></dl></div><p>
This emits the event loop destroy signal, closes the event loop file descriptor, and frees loop.</p><p>If the event loop has existing sources, those cannot be safely removed afterwards. Therefore one must call <a class="link" href="apc.html#Server-structwl__event__source_1afe37015d67b81ae82609f2b8aa78cc4f">wl_event_source_remove()</a> on all event sources before destroying the event loop context. </p></dd><dt><a name="Server-structwl__event__loop_1aefc44b3062c22d2506ff42460f091396"></a><span class="term">wl_event_loop_dispatch_idle
            - 
Dispatch the idle sources.         </span></dt><dd><pre class="synopsis">void wl_event_loop_dispatch_idle(struct wl_event_loop *loop)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop whose idle sources are dispatched.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a90d88ae62b26a25f709977c45b300716">wl_event_loop_add_idle()</a> 
</p></dd><dt><a name="Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b"></a><span class="term">wl_event_loop_dispatch
            - 
Wait for events and dispatch them.         </span></dt><dd><pre class="synopsis">int wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop whose sources to wait for. </dd><dt><span class="term">timeout</span></dt><dd>
The polling timeout in milliseconds. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 for success, -1 for polling (or timer update) error.</dd></dl></div><p>
All the associated event sources are polled. This function blocks until any event source delivers an event (idle sources excluded), or the timeout expires. A timeout of -1 disables the timeout, causing the function to block indefinitely. A timeout of zero causes the poll to always return immediately.</p><p>All idle sources are dispatched before blocking. An idle source is destroyed when it is dispatched. After blocking, all other ready sources are dispatched. Then, idle sources are dispatched again, in case the dispatched events created idle sources. Finally, all sources marked with <a class="link" href="apc.html#Server-structwl__event__source_1aa079264c57dd12168c691c000724efcf">wl_event_source_check()</a> are dispatched in a loop until their dispatch functions all return zero. </p></dd><dt><a name="Server-structwl__event__loop_1a58c8aa06a2d240a49a95a91eddcba8e5"></a><span class="term">wl_event_loop_get_fd
            - 
Get the event loop file descriptor.         </span></dt><dd><pre class="synopsis">int wl_event_loop_get_fd(struct wl_event_loop *loop)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop context. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The aggregate file descriptor.</dd></dl></div><p>
This function returns the aggregate file descriptor, that represents all the event sources (idle sources excluded) associated with the given event loop context. When any event source makes an event available, it will be reflected in the aggregate file descriptor.</p><p>When the aggregate file descriptor delivers an event, one can call <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> on the event loop context to dispatch all the available events. </p></dd><dt><a name="Server-structwl__event__loop_1a6b564d8d4183d71f1fdf06e751d84d51"></a><span class="term">wl_event_loop_add_destroy_listener
            - 
Register a destroy listener for an event loop context.         </span></dt><dd><pre class="synopsis">void wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, struct wl_listener *listener)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop context whose destruction to listen for. </dd><dt><span class="term">listener</span></dt><dd>
The listener with the callback to be called.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a> 
</p></dd><dt><a name="Server-structwl__event__loop_1af282cb9f57fadd1fc0dd47ea68c3bae3"></a><span class="term">wl_event_loop_get_destroy_listener
            - 
Get the listener struct for the specified callback.         </span></dt><dd><pre class="synopsis">struct wl_listener * wl_event_loop_get_destroy_listener(struct wl_event_loop *loop, wl_notify_func_t notify)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop context to inspect. </dd><dt><span class="term">notify</span></dt><dd>
The destroy callback to find. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a> registered to the event loop context with the given callback pointer. </dd></dl></div><p>
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__event__source"></a>wl_event_source
                - 
An abstract event source.     </h2></div></div></div><p>This is the generic type for fd, timer, signal, and idle sources. Functions that operate on specific source types must not be used with a different type, even if the function signature allows it. </p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__event__source_1a09e702384ed869548c72f3576399c581"></a><span class="term">wl_event_loop_fd_func_t
            - 
File descriptor dispatch function type.         </span></dt><dd><pre class="synopsis">typedef int(* wl_event_loop_fd_func_t) (int fd, uint32_t mask, void *data))(int fd, uint32_t mask, void *data)</pre><p>Functions of this type are used as callbacks for file descriptor events.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">fd</span></dt><dd>
The file descriptor delivering the event. </dd><dt><span class="term">mask</span></dt><dd>
Describes the kind of the event as a bitwise-or of: WL_EVENT_READABLE, WL_EVENT_WRITABLE, WL_EVENT_HANGUP, WL_EVENT_ERROR. </dd><dt><span class="term">data</span></dt><dd>
The user data argument of the related <a class="link" href="apc.html#Server-structwl__event__source_1a0e7ce1f52dfe04c73b6a7c2263c7ef25">wl_event_loop_add_fd()</a> call. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>If the event source is registered for re-check with <a class="link" href="apc.html#Server-structwl__event__source_1aa079264c57dd12168c691c000724efcf">wl_event_source_check()</a>: 0 for all done, 1 for needing a re-check. If not registered, the return value is ignored and should be zero.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a0e7ce1f52dfe04c73b6a7c2263c7ef25">wl_event_loop_add_fd()</a> 
</p></dd><dt><a name="Server-structwl__event__source_1a59bc490bf28b48e0af908ab91649938a"></a><span class="term">wl_event_loop_timer_func_t
            - 
Timer dispatch function type.         </span></dt><dd><pre class="synopsis">typedef int(* wl_event_loop_timer_func_t) (void *data))(void *data)</pre><p>Functions of this type are used as callbacks for timer expiry.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">data</span></dt><dd>
The user data argument of the related <a class="link" href="apc.html#Server-structwl__event__source_1a39374f19a73472f63fab4267a14adc10">wl_event_loop_add_timer()</a> call. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>If the event source is registered for re-check with <a class="link" href="apc.html#Server-structwl__event__source_1aa079264c57dd12168c691c000724efcf">wl_event_source_check()</a>: 0 for all done, 1 for needing a re-check. If not registered, the return value is ignored and should be zero.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a39374f19a73472f63fab4267a14adc10">wl_event_loop_add_timer()</a> 
</p></dd><dt><a name="Server-structwl__event__source_1a431b418976144a8ebe6b19bc24206d20"></a><span class="term">wl_event_loop_signal_func_t
            - 
Signal dispatch function type.         </span></dt><dd><pre class="synopsis">typedef int(* wl_event_loop_signal_func_t) (int signal_number, void *data))(int signal_number, void *data)</pre><p>Functions of this type are used as callbacks for (POSIX) signals.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">signal_number</span></dt><dd>
</dd><dt><span class="term">data</span></dt><dd>
The user data argument of the related <a class="link" href="apc.html#Server-structwl__event__source_1a1706e2490502a95f24ccb59cbae3e2f8">wl_event_loop_add_signal()</a> call. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>If the event source is registered for re-check with <a class="link" href="apc.html#Server-structwl__event__source_1aa079264c57dd12168c691c000724efcf">wl_event_source_check()</a>: 0 for all done, 1 for needing a re-check. If not registered, the return value is ignored and should be zero.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a1706e2490502a95f24ccb59cbae3e2f8">wl_event_loop_add_signal()</a> 
</p></dd><dt><a name="Server-structwl__event__source_1ae526dfa099f9ba69285e275c82794a9b"></a><span class="term">wl_event_loop_idle_func_t
            - 
Idle task function type.         </span></dt><dd><pre class="synopsis">typedef void(* wl_event_loop_idle_func_t) (void *data))(void *data)</pre><p>Functions of this type are used as callbacks before blocking in <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">data</span></dt><dd>
The user data argument of the related <a class="link" href="apc.html#Server-structwl__event__source_1a90d88ae62b26a25f709977c45b300716">wl_event_loop_add_idle()</a> call.</dd></dl></div><p>

  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a90d88ae62b26a25f709977c45b300716">wl_event_loop_add_idle()</a> <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> 
</p></dd><dt><a name="Server-structwl__event__source_1a0e7ce1f52dfe04c73b6a7c2263c7ef25"></a><span class="term">wl_event_loop_add_fd
            - 
Create a file descriptor event source.         </span></dt><dd><pre class="synopsis">struct wl_event_source * wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop that will process the new source. </dd><dt><span class="term">fd</span></dt><dd>
The file descriptor to watch. </dd><dt><span class="term">mask</span></dt><dd>
A bitwise-or of which events to watch for: WL_EVENT_READABLE, WL_EVENT_WRITABLE. </dd><dt><span class="term">func</span></dt><dd>
The file descriptor dispatch function. </dd><dt><span class="term">data</span></dt><dd>
User data. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A new file descriptor event source.</dd></dl></div><p>
The given file descriptor is initially watched for the events given in mask. This can be changed as needed with <a class="link" href="apc.html#Server-structwl__event__source_1afe73f9ff59d489e9f27eb9c0e3058a02">wl_event_source_fd_update()</a>.</p><p>If it is possible that program execution causes the file descriptor to be read while leaving the data in a buffer without actually processing it, it may be necessary to register the file descriptor source to be re-checked, see <a class="link" href="apc.html#Server-structwl__event__source_1aa079264c57dd12168c691c000724efcf">wl_event_source_check()</a>. This will ensure that the dispatch function gets called even if the file descriptor is not readable or writable anymore. This is especially useful with IPC libraries that automatically buffer incoming data, possibly as a side-effect of other operations.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a09e702384ed869548c72f3576399c581">wl_event_loop_fd_func_t</a> 
</p></dd><dt><a name="Server-structwl__event__source_1afe73f9ff59d489e9f27eb9c0e3058a02"></a><span class="term">wl_event_source_fd_update
            - 
Update a file descriptor source's event mask.         </span></dt><dd><pre class="synopsis">int wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">source</span></dt><dd>
The file descriptor event source to update. </dd><dt><span class="term">mask</span></dt><dd>
The new mask, a bitwise-or of: WL_EVENT_READABLE, WL_EVENT_WRITABLE. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 on success, -1 on failure.</dd></dl></div><p>
This changes which events, readable and/or writable, cause the dispatch callback to be called on.</p><p>File descriptors are usually writable to begin with, so they do not need to be polled for writable until a write actually fails. When a write fails, the event mask can be changed to poll for readable and writable, delivering a dispatch callback when it is possible to write more. Once all data has been written, the mask can be changed to poll only for readable to avoid busy-looping on dispatch.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a0e7ce1f52dfe04c73b6a7c2263c7ef25">wl_event_loop_add_fd()</a> 
</p></dd><dt><a name="Server-structwl__event__source_1a39374f19a73472f63fab4267a14adc10"></a><span class="term">wl_event_loop_add_timer
            - 
Create a timer event source.         </span></dt><dd><pre class="synopsis">struct wl_event_source * wl_event_loop_add_timer(struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop that will process the new source. </dd><dt><span class="term">func</span></dt><dd>
The timer dispatch function. </dd><dt><span class="term">data</span></dt><dd>
User data. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A new timer event source.</dd></dl></div><p>
The timer is initially disarmed. It needs to be armed with a call to <a class="link" href="apc.html#Server-structwl__event__source_1a0164a47e9e8356af90c9d5c1de9f5487">wl_event_source_timer_update()</a> before it can trigger a dispatch call.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a59bc490bf28b48e0af908ab91649938a">wl_event_loop_timer_func_t</a> 
</p></dd><dt><a name="Server-structwl__event__source_1a0164a47e9e8356af90c9d5c1de9f5487"></a><span class="term">wl_event_source_timer_update
            - 
Arm or disarm a timer.         </span></dt><dd><pre class="synopsis">int wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">source</span></dt><dd>
The timer event source to modify. </dd><dt><span class="term">ms_delay</span></dt><dd>
The timeout in milliseconds. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 on success, -1 on failure.</dd></dl></div><p>
If the timeout is zero, the timer is disarmed.</p><p>If the timeout is non-zero, the timer is set to expire after the given timeout in milliseconds. When the timer expires, the dispatch function set with <a class="link" href="apc.html#Server-structwl__event__source_1a39374f19a73472f63fab4267a14adc10">wl_event_loop_add_timer()</a> is called once from <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a>. If another dispatch is desired after another expiry, <a class="link" href="apc.html#Server-structwl__event__source_1a0164a47e9e8356af90c9d5c1de9f5487">wl_event_source_timer_update()</a> needs to be called again. </p></dd><dt><a name="Server-structwl__event__source_1a1706e2490502a95f24ccb59cbae3e2f8"></a><span class="term">wl_event_loop_add_signal
            - 
Create a POSIX signal event source.         </span></dt><dd><pre class="synopsis">struct wl_event_source * wl_event_loop_add_signal(struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop that will process the new source. </dd><dt><span class="term">signal_number</span></dt><dd>
Number of the signal to watch for. </dd><dt><span class="term">func</span></dt><dd>
The signal dispatch function. </dd><dt><span class="term">data</span></dt><dd>
User data. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A new signal event source.</dd></dl></div><p>
This function blocks the normal delivery of the given signal in the calling thread, and creates a "watch" for it. Signal delivery no longer happens asynchronously, but by <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> calling the dispatch callback function func.</p><p>It is the caller's responsibility to ensure that all other threads have also blocked the signal.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__event__source_1a431b418976144a8ebe6b19bc24206d20">wl_event_loop_signal_func_t</a> 
</p></dd><dt><a name="Server-structwl__event__source_1a90d88ae62b26a25f709977c45b300716"></a><span class="term">wl_event_loop_add_idle
            - 
Create an idle task.         </span></dt><dd><pre class="synopsis">struct wl_event_source * wl_event_loop_add_idle(struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">loop</span></dt><dd>
The event loop that will process the new task. </dd><dt><span class="term">func</span></dt><dd>
The idle task dispatch function. </dd><dt><span class="term">data</span></dt><dd>
User data. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>A new idle task (an event source).</dd></dl></div><p>
Idle tasks are dispatched before <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> goes to sleep. See <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> for more details.</p><p>Idle tasks fire once, and are automatically destroyed right after the callback function has been called.</p><p>An idle task can be cancelled before the callback has been called by <a class="link" href="apc.html#Server-structwl__event__source_1afe37015d67b81ae82609f2b8aa78cc4f">wl_event_source_remove()</a>. Calling <a class="link" href="apc.html#Server-structwl__event__source_1afe37015d67b81ae82609f2b8aa78cc4f">wl_event_source_remove()</a> after or from within the callback results in undefined behaviour.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__event__source_1ae526dfa099f9ba69285e275c82794a9b">wl_event_loop_idle_func_t</a> 
</p></dd><dt><a name="Server-structwl__event__source_1aa079264c57dd12168c691c000724efcf"></a><span class="term">wl_event_source_check
            - 
Mark event source to be re-checked.         </span></dt><dd><pre class="synopsis">void wl_event_source_check(struct wl_event_source *source)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">source</span></dt><dd>
The event source to be re-checked.</dd></dl></div><p>
This function permanently marks the event source to be re-checked after the normal dispatch of sources in <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a>. Re-checking will keep iterating over all such event sources until the dispatch function for them all returns zero.</p><p>Re-checking is used on sources that may become ready to dispatch as a side-effect of dispatching themselves or other event sources, including idle sources. Re-checking ensures all the incoming events have been fully drained before <a class="link" href="apc.html#Server-structwl__event__loop_1aaa3fdd5590365a4a2106c9814ca9b31b">wl_event_loop_dispatch()</a> returns. </p></dd><dt><a name="Server-structwl__event__source_1afe37015d67b81ae82609f2b8aa78cc4f"></a><span class="term">wl_event_source_remove
            - 
Remove an event source from its event loop.         </span></dt><dd><pre class="synopsis">int wl_event_source_remove(struct wl_event_source *source)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">source</span></dt><dd>
The event source to be removed. </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>Zero.</dd></dl></div><p>
The event source is removed from the event loop it was created for, and is effectively destroyed. This invalidates source . The dispatch function of the source will no longer be called through this source. </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__global"></a>wl_global</h2></div></div></div><p></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__interface"></a>wl_interface
                - 
Protocol object interface.     </h2></div></div></div><p>A <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> describes the API of a protocol object defined in the Wayland protocol specification. The protocol implementation uses a <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> within its marshalling machinery for encoding client requests.</p><p>The name of a <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> is the name of the corresponding protocol interface, and version represents the version of the interface. The members method_count and event_count represent the number of methods (requests) and events in the respective <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> members.</p><p>For example, consider a protocol interface foo, marked as version 1, with two requests and one event.</p><p>
    </p><pre class="programlisting">&lt;interface name="foo" version="1"&gt;
  &lt;request name="a"&gt;&lt;/request&gt;
  &lt;request name="b"&gt;&lt;/request&gt;
  &lt;event name="c"&gt;&lt;/event&gt;
&lt;/interface&gt;
</pre><p>
  </p><p>Given two <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> arrays foo_requests and foo_events, a <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> for foo might be:</p><p>
    </p><pre class="programlisting">struct wl_interface foo_interface = {
        "foo", 1,
        2, foo_requests,
        1, foo_events
};
</pre><p>
  </p><p><span class="emphasis"><em>Note: The server side of the protocol may define interface implementation types that incorporate the term interface in their name. Take care to not confuse these server-side structs with a <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> variable whose name also ends in interface. For example, while the server may define a type struct wl_foo_interface, the client may define a struct <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> wl_foo_interface.</em></span>

  See also: <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> 

  See also: wl_proxy 

  See also: Interfaces 

  See also: Versioning 
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__list"></a>wl_list
                - 
Doubly-linked list.     </h2></div></div></div><p>On its own, an instance of struct <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> represents the sentinel head of a doubly-linked list, and must be initialized using <a class="link" href="apc.html#Server-structwl__list_1a1d5c9d41e224538b2edf324c7f8b1ac8">wl_list_init()</a>. When empty, the list head's next and prev members point to the list head itself, otherwise next references the first element in the list, and prev refers to the last element in the list.</p><p>Use the struct <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> type to represent both the list head and the links between elements within the list. Use <a class="link" href="apc.html#Server-structwl__list_1a5c6aa8f61fa63374f1c77e7e4462a38a">wl_list_empty()</a> to determine if the list is empty in O(1).</p><p>All elements in the list must be of the same type. The element type must have a struct <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> member, often named link by convention. Prior to insertion, there is no need to initialize an element's link - invoking <a class="link" href="apc.html#Server-structwl__list_1a1d5c9d41e224538b2edf324c7f8b1ac8">wl_list_init()</a> on an individual list element's struct <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> member is unnecessary if the very next operation is <a class="link" href="apc.html#Server-structwl__list_1aa7eaac0d363c0473bfc3e8172b0dfd98">wl_list_insert()</a>. However, a common idiom is to initialize an element's link prior to removal - ensure safety by invoking <a class="link" href="apc.html#Server-structwl__list_1a1d5c9d41e224538b2edf324c7f8b1ac8">wl_list_init()</a> before <a class="link" href="apc.html#Server-structwl__list_1aa16d739aaa041dde9d34ad4bcb4d4c83">wl_list_remove()</a>.</p><p>Consider a list reference struct <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> foo_list, an element type as struct element, and an element's link member as struct <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> link.</p><p>The following code initializes a list and adds three elements to it.</p><p>
    </p><pre class="programlisting">struct wl_list foo_list;

struct element {
        int foo;
        struct wl_list link;
};
struct element e1, e2, e3;

wl_list_init(&amp;foo_list);
wl_list_insert(&amp;foo_list, &amp;e1.link);   // e1 is the first element
wl_list_insert(&amp;foo_list, &amp;e2.link);   // e2 is now the first element
wl_list_insert(&amp;e2.link, &amp;e3.link); // insert e3 after e2
</pre><p>
  </p><p>The list now looks like [e2, e3, e1].</p><p>The <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> API provides some iterator macros. For example, to iterate a list in ascending order:</p><p>
    </p><pre class="programlisting">struct element *e;
wl_list_for_each(e, foo_list, link) {
        do_something_with_element(e);
}
</pre><p>
  </p><p>See the documentation of each iterator for details. 
  See also: http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h 
</p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__list_1a72c2827d3103691f9e3299babfbf0704"></a><span class="term">prev
            - 
Previous list element.         </span></dt><dd><pre class="synopsis">struct wl_list* wl_list::prev</pre></dd><dt><a name="Server-structwl__list_1aa0454596900ed769fb2f033fbb96bf2c"></a><span class="term">next
            - 
Next list element.         </span></dt><dd><pre class="synopsis">struct wl_list* wl_list::next</pre></dd><dt><a name="Server-structwl__list_1a1d5c9d41e224538b2edf324c7f8b1ac8"></a><span class="term">wl_list_init
            - 
Initializes the list.         </span></dt><dd><pre class="synopsis">void wl_list_init(struct wl_list *list)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">list</span></dt><dd>
List to initialize </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1aa7eaac0d363c0473bfc3e8172b0dfd98"></a><span class="term">wl_list_insert
            - 
Inserts an element into the list, after the element represented by list.         </span></dt><dd><pre class="synopsis">void wl_list_insert(struct wl_list *list, struct wl_list *elm)</pre><p>When list is a reference to the list itself (the head), set the containing struct of elm as the first element in the list.</p><p><span class="emphasis"><em>Note: If elm is already part of a list, inserting it again will lead to list corruption.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">list</span></dt><dd>
List element after which the new element is inserted </dd><dt><span class="term">elm</span></dt><dd>
Link of the containing struct to insert into the list </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1aa16d739aaa041dde9d34ad4bcb4d4c83"></a><span class="term">wl_list_remove
            - 
Removes an element from the list.         </span></dt><dd><pre class="synopsis">void wl_list_remove(struct wl_list *elm)</pre><p><span class="emphasis"><em>Note: This operation leaves elm in an invalid state.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">elm</span></dt><dd>
Link of the containing struct to remove from the list </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1a2710186b02864dc2b18a46993aa9c2e0"></a><span class="term">wl_list_length
            - 
Determines the length of the list.         </span></dt><dd><pre class="synopsis">int wl_list_length(const struct wl_list *list)</pre><p><span class="emphasis"><em>Note: This is an O(n) operation.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">list</span></dt><dd>
List whose length is to be determined</dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>Number of elements in the list </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1a5c6aa8f61fa63374f1c77e7e4462a38a"></a><span class="term">wl_list_empty
            - 
Determines if the list is empty.         </span></dt><dd><pre class="synopsis">int wl_list_empty(const struct wl_list *list)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">list</span></dt><dd>
List whose emptiness is to be determined</dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>1 if empty, or 0 if not empty </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1ac714f6eedd52286c8b6d9884cc7c8492"></a><span class="term">wl_list_insert_list
            - 
Inserts all of the elements of one list into another, after the element represented by list.         </span></dt><dd><pre class="synopsis">void wl_list_insert_list(struct wl_list *list, struct wl_list *other)</pre><p><span class="emphasis"><em>Note: This leaves other in an invalid state.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">list</span></dt><dd>
List element after which the other list elements will be inserted </dd><dt><span class="term">other</span></dt><dd>
List of elements to insert </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1a449407fe3c8f273e38bc2253093cb6fb"></a><span class="term">wl_list_for_each
            - 
Iterates over a list.         </span></dt><dd><pre class="synopsis"></pre><p>This macro expresses a for-each iterator for <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a>. Given a list and <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> link member name (often named link by convention), this macro assigns each element in the list to pos, which can then be referenced in a trailing code block. For example, given a <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a> of struct message elements:</p><p>
          </p><pre class="programlisting">struct message {
        char *contents;
        wl_list link;
};

struct wl_list *message_list;
// Assume message_list now "contains" many messages

struct message *m;
wl_list_for_each(m, message_list, link) {
        do_something_with_message(m);
}
</pre><p>
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">pos</span></dt><dd>
Cursor that each list element will be assigned to </dd><dt><span class="term">head</span></dt><dd>
Head of the list to iterate over </dd><dt><span class="term">member</span></dt><dd>
Name of the link member within the element struct </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1a43d51e3b5ae8b58f3391f3d43687f852"></a><span class="term">wl_list_for_each_safe
            - 
Iterates over a list, safe against removal of the list element.         </span></dt><dd><pre class="synopsis"></pre><p><span class="emphasis"><em>Note: Only removal of the current element, pos, is safe. Removing any other element during traversal may lead to a loop malfunction.</em></span>

  See also: <a class="link" href="apc.html#Server-structwl__list_1a449407fe3c8f273e38bc2253093cb6fb">wl_list_for_each()</a>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">pos</span></dt><dd>
Cursor that each list element will be assigned to </dd><dt><span class="term">tmp</span></dt><dd>
Temporary pointer of the same type as pos </dd><dt><span class="term">head</span></dt><dd>
Head of the list to iterate over </dd><dt><span class="term">member</span></dt><dd>
Name of the link member within the element struct </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1a2ee1918119b03d36ed3004984efb9dc9"></a><span class="term">wl_list_for_each_reverse
            - 
Iterates backwards over a list.         </span></dt><dd><pre class="synopsis"></pre><p>
  See also: <a class="link" href="apc.html#Server-structwl__list_1a449407fe3c8f273e38bc2253093cb6fb">wl_list_for_each()</a>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">pos</span></dt><dd>
Cursor that each list element will be assigned to </dd><dt><span class="term">head</span></dt><dd>
Head of the list to iterate over </dd><dt><span class="term">member</span></dt><dd>
Name of the link member within the element struct </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__list_1ac84e06e7914226b2678ff5f351d7f9e8"></a><span class="term">wl_list_for_each_reverse_safe
            - 
Iterates backwards over a list, safe against removal of the list element.         </span></dt><dd><pre class="synopsis"></pre><p><span class="emphasis"><em>Note: Only removal of the current element, pos, is safe. Removing any other element during traversal may lead to a loop malfunction.</em></span>

  See also: <a class="link" href="apc.html#Server-structwl__list_1a449407fe3c8f273e38bc2253093cb6fb">wl_list_for_each()</a>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">pos</span></dt><dd>
Cursor that each list element will be assigned to </dd><dt><span class="term">tmp</span></dt><dd>
Temporary pointer of the same type as pos </dd><dt><span class="term">head</span></dt><dd>
Head of the list to iterate over </dd><dt><span class="term">member</span></dt><dd>
Name of the link member within the element struct </dd></dl></div><p>
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__listener"></a>wl_listener
                - 
A single listener for Wayland signals.     </h2></div></div></div><p><a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a> provides the means to listen for <a class="link" href="apc.html#Server-structwl__signal" title="wl_signal - A source of a type of observable event.">wl_signal</a> notifications. Many Wayland objects use <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a> for notification of significant events like object destruction.</p><p>Clients should create <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a> objects manually and can register them as listeners to signals using <a class="link" href="apc.html#Server-structwl__signal_1aa8bcd3b8e250cfe35ed064d5af589096">wl_signal_add</a>, assuming the signal is directly accessible. For opaque structs like <a class="link" href="apc.html#Server-structwl__event__loop" title="wl_event_loop - An event loop context.">wl_event_loop</a>, adding a listener should be done through provided accessor methods. A listener can only listen to one signal at a time.</p><p>
    </p><pre class="programlisting">struct wl_listener your_listener;

your_listener.notify = your_callback_method;

// Direct access
wl_signal_add(&amp;some_object-&gt;destroy_signal, &amp;your_listener);

// Accessor access
wl_event_loop *loop = ...;
wl_event_loop_add_destroy_listener(loop, &amp;your_listener);
</pre><p>
  </p><p>If the listener is part of a larger struct, <a class="link" href="apc.html#Server-wayland-util_8h_1a09e3b64ee2195e1b80191aa1884d45aa">wl_container_of</a> can be used to retrieve a pointer to it:</p><p>
    </p><pre class="programlisting">void your_listener(struct wl_listener *listener, void *data)
{
        struct your_data *data;

        your_data = wl_container_of(listener, data, your_member_name);
}
</pre><p>
  </p><p>If you need to remove a listener from a signal, use <a class="link" href="apc.html#Server-structwl__list_1aa16d739aaa041dde9d34ad4bcb4d4c83">wl_list_remove()</a>.</p><p>
    </p><pre class="programlisting">wl_list_remove(&amp;your_listener.link);
</pre><p>
  </p><p>
  See also: <a class="link" href="apc.html#Server-structwl__signal" title="wl_signal - A source of a type of observable event.">wl_signal</a> 
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__message"></a>wl_message
                - 
Protocol message signature.     </h2></div></div></div><p>A <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> describes the signature of an actual protocol message, such as a request or event, that adheres to the Wayland protocol wire format. The protocol implementation uses a <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> within its demarshal machinery for decoding messages between a compositor and its clients. In a sense, a <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> is to a protocol message like a class is to an object.</p><p>The name of a <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> is the name of the corresponding protocol message.</p><p>The signature is an ordered list of symbols representing the data types of message arguments and, optionally, a protocol version and indicators for nullability. A leading integer in the signature indicates the since version of the protocol message. A ? preceding a data type symbol indicates that the following argument type is nullable. While it is a protocol violation to send messages with non-nullable arguments set to NULL, event handlers in clients might still get called with non-nullable object arguments set to NULL. This can happen when the client destroyed the object being used as argument on its side and an event referencing that object was sent before the server knew about its destruction. As this race cannot be prevented, clients should - as a general rule - program their event handlers such that they can handle object arguments declared non-nullable being NULL gracefully.</p><p>When no arguments accompany a message, signature is an empty string.</p><p>Symbols:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">i: int</li><li class="listitem">u: uint</li><li class="listitem">f: fixed</li><li class="listitem">s: string</li><li class="listitem">o: object</li><li class="listitem">n: new_id</li><li class="listitem">a: array</li><li class="listitem">h: fd</li><li class="listitem">?: following argument is nullable</li></ul></div><p>
</p><p>While demarshaling primitive arguments is straightforward, when demarshaling messages containing object or new_id arguments, the protocol implementation often must determine the type of the object. The types of a <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> is an array of <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> references that correspond to o and n arguments in signature, with NULL placeholders for arguments with non-object types.</p><p>Consider the protocol event <a class="link" href="apc.html#Server-structwl__display" title="wl_display">wl_display</a> delete_id that has a single uint argument. The <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> is:</p><p>
    </p><pre class="programlisting">{ "delete_id", "u", [NULL] }
</pre><p>
  </p><p>Here, the message name is "delete_id", the signature is "u", and the argument types is [NULL], indicating that the uint argument has no corresponding <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> since it is a primitive argument.</p><p>In contrast, consider a wl_foo interface supporting protocol request bar that has existed since version 2, and has two arguments: a uint and an object of type wl_baz_interface that may be NULL. Such a <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> might be:</p><p>
    </p><pre class="programlisting">{ "bar", "2u?o", [NULL, &amp;wl_baz_interface] }
</pre><p>
  </p><p>Here, the message name is "bar", and the signature is "2u?o". Notice how the 2 indicates the protocol version, the u indicates the first argument type is uint, and the ?o indicates that the second argument is an object that may be NULL. Lastly, the argument types array indicates that no <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> corresponds to the first argument, while the type wl_baz_interface corresponds to the second argument.</p><p>
  See also: <a class="link" href="apc.html#Server-unionwl__argument" title="wl_argument - Protocol message argument data types.">wl_argument</a> 

  See also: <a class="link" href="apc.html#Server-structwl__interface" title="wl_interface - Protocol object interface.">wl_interface</a> 

  See also: Wire Format 
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__object"></a>wl_object
                - 
A protocol object.     </h2></div></div></div><p>A <a class="link" href="apc.html#Server-structwl__object" title="wl_object - A protocol object.">wl_object</a> is an opaque struct identifying the protocol object underlying a wl_proxy or <a class="link" href="apc.html#Server-structwl__resource" title="wl_resource">wl_resource</a>.</p><p><span class="emphasis"><em>Note: Functions accessing a <a class="link" href="apc.html#Server-structwl__object" title="wl_object - A protocol object.">wl_object</a> are not normally used by client code. Clients should normally use the higher level interface generated by the scanner to interact with compositor objects. </em></span>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__protocol__logger"></a>wl_protocol_logger</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__protocol__logger_1ac5bfbf098cbecb788190bc12e3becad7"></a><span class="term">wl_protocol_logger_destroy
            - 
Destroys a protocol logger.         </span></dt><dd><pre class="synopsis">void wl_protocol_logger_destroy(struct wl_protocol_logger *logger)</pre><p>This function destroys a protocol logger and removes it from the display it was added to with wl_display_add_protocol_logger. The logger object becomes invalid after calling this function.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__display_1a4dc118c686e362aba0b3c6c8874efc3d">wl_display_add_protocol_logger</a> 
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__protocol__logger__message"></a>wl_protocol_logger_message</h2></div></div></div><p></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__resource"></a>wl_resource</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__resource_1aabbdc4ffb1abf525d1818c943a8c80d6"></a><span class="term">wl_resource_get_class
            - 
Retrieve the interface name (class) of a resource object.         </span></dt><dd><pre class="synopsis">const char * wl_resource_get_class(struct wl_resource *resource)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">resource</span></dt><dd>
The resource object </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__resource_1a50388ae686cecfe7a9940c995d5d120b"></a><span class="term">wl_resource_create
            - 
Create a new resource object.         </span></dt><dd><pre class="synopsis">struct wl_resource * wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client owner of the new resource. </dd><dt><span class="term">interface</span></dt><dd>
The interface of the new resource. </dd><dt><span class="term">version</span></dt><dd>
The version of the new resource. </dd><dt><span class="term">id</span></dt><dd>
The id of the new resource. If 0, an available id will be used.</dd></dl></div><p>
Listeners added with wl_client_add_resource_created_listener will be notified at the end of this function. </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__resource__iterator__context"></a>wl_resource_iterator_context</h2></div></div></div><p></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__shm__buffer"></a>wl_shm_buffer</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__shm__buffer_1a9104a38eae80c5ba92c8ab030c70192f"></a><span class="term">wl_shm_buffer_get_data
            - 
Get a pointer to the memory for the SHM buffer.         </span></dt><dd><pre class="synopsis">void * wl_shm_buffer_get_data(struct wl_shm_buffer *buffer)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">buffer</span></dt><dd>
The buffer object</dd></dl></div><p>
Returns a pointer which can be used to read the data contained in the given SHM buffer.</p><p>As this buffer is memory-mapped, reading from it may generate SIGBUS signals. This can happen if the client claims that the buffer is larger than it is or if something truncates the underlying file. To prevent this signal from causing the compositor to crash you should call wl_shm_buffer_begin_access and wl_shm_buffer_end_access around code that reads from the memory. </p></dd><dt><a name="Server-structwl__shm__buffer_1abc49a49c3586821d6ec4efe7ea915305"></a><span class="term">wl_shm_buffer_ref_pool
            - 
Get a reference to a shm_buffer's shm_pool.         </span></dt><dd><pre class="synopsis">struct wl_shm_pool * wl_shm_buffer_ref_pool(struct wl_shm_buffer *buffer)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">buffer</span></dt><dd>
The buffer object</dd></dl></div><p>
Returns a pointer to a buffer's shm_pool and increases the shm_pool refcount.</p><p>The compositor must remember to call wl_shm_pool_unref when it no longer needs the reference to ensure proper destruction of the pool.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__shm__pool_1a2349156a6b7940645a4754e6c1690051">wl_shm_pool_unref</a> 
</p></dd><dt><a name="Server-structwl__shm__buffer_1a809cb5d6b33338c62bbca6daa4138667"></a><span class="term">wl_shm_buffer_begin_access
            - 
Mark that the given SHM buffer is about to be accessed.         </span></dt><dd><pre class="synopsis">void wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">buffer</span></dt><dd>
The SHM buffer</dd></dl></div><p>
An SHM buffer is a memory-mapped file given by the client. According to POSIX, reading from a memory-mapped region that extends off the end of the file will cause a SIGBUS signal to be generated. Normally this would cause the compositor to terminate. In order to make the compositor robust against clients that change the size of the underlying file or lie about its size, you should protect access to the buffer by calling this function before reading from the memory and call wl_shm_buffer_end_access afterwards. This will install a signal handler for SIGBUS which will prevent the compositor from crashing.</p><p>After calling this function the signal handler will remain installed for the lifetime of the compositor process. Note that this function will not work properly if the compositor is also installing its own handler for SIGBUS.</p><p>If a SIGBUS signal is received for an address within the range of the SHM pool of the given buffer then the client will be sent an error event when wl_shm_buffer_end_access is called. If the signal is for an address outside that range then the signal handler will reraise the signal which would will likely cause the compositor to terminate.</p><p>It is safe to nest calls to these functions as long as the nested calls are all accessing the same buffer. The number of calls to wl_shm_buffer_end_access must match the number of calls to wl_shm_buffer_begin_access. These functions are thread-safe and it is allowed to simultaneously access different buffers or the same buffer from multiple threads. </p></dd><dt><a name="Server-structwl__shm__buffer_1a030db6056ef08836e9dee21a8087e2c1"></a><span class="term">wl_shm_buffer_end_access
            - 
Ends the access to a buffer started by wl_shm_buffer_begin_access.         </span></dt><dd><pre class="synopsis">void wl_shm_buffer_end_access(struct wl_shm_buffer *buffer)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">buffer</span></dt><dd>
The SHM buffer</dd></dl></div><p>
This should be called after wl_shm_buffer_begin_access once the buffer is no longer being accessed. If a SIGBUS signal was generated in-between these two calls then the resource for the given buffer will be sent an error. </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__shm__pool"></a>wl_shm_pool</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__shm__pool_1a2349156a6b7940645a4754e6c1690051"></a><span class="term">wl_shm_pool_unref
            - 
Unreference a shm_pool.         </span></dt><dd><pre class="synopsis">void wl_shm_pool_unref(struct wl_shm_pool *pool)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">pool</span></dt><dd>
The pool object</dd></dl></div><p>
Drops a reference to a <a class="link" href="apc.html#Server-structwl__shm__pool" title="wl_shm_pool">wl_shm_pool</a> object.</p><p>This is only necessary if the compositor has explicitly taken a reference with <a class="link" href="apc.html#Server-structwl__shm__buffer_1abc49a49c3586821d6ec4efe7ea915305">wl_shm_buffer_ref_pool()</a>, otherwise the pool will be automatically destroyed when appropriate.</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__shm__buffer_1abc49a49c3586821d6ec4efe7ea915305">wl_shm_buffer_ref_pool</a> 
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__shm__sigbus__data"></a>wl_shm_sigbus_data</h2></div></div></div><p></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__signal"></a>wl_signal
                - 
A source of a type of observable event.     </h2></div></div></div><p>Signals are recognized points where significant events can be observed. Compositors as well as the server can provide signals. Observers are <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a>'s that are added through <a class="link" href="apc.html#Server-structwl__signal_1aa8bcd3b8e250cfe35ed064d5af589096">wl_signal_add</a>. Signals are emitted using <a class="link" href="apc.html#Server-structwl__signal_1afe73f44f7f1b517c9c0ba90829c93309">wl_signal_emit</a>, which will invoke all listeners until that listener is removed by <a class="link" href="apc.html#Server-structwl__list_1aa16d739aaa041dde9d34ad4bcb4d4c83">wl_list_remove()</a> (or whenever the signal is destroyed).</p><p>
  See also: <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a> for more information on using <a class="link" href="apc.html#Server-structwl__signal" title="wl_signal - A source of a type of observable event.">wl_signal</a> 
</p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-structwl__signal_1aeb25ddd9c813189203d15723e983b320"></a><span class="term">wl_signal_init
            - 
Initialize a new wl_signal for use.         </span></dt><dd><pre class="synopsis">static void wl_signal_init(struct wl_signal *signal)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">signal</span></dt><dd>
The signal that will be initialized </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__signal_1aa8bcd3b8e250cfe35ed064d5af589096"></a><span class="term">wl_signal_add
            - 
Add the specified listener to this signal.         </span></dt><dd><pre class="synopsis">static void wl_signal_add(struct wl_signal *signal, struct wl_listener *listener)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">signal</span></dt><dd>
The signal that will emit events to the listener </dd><dt><span class="term">listener</span></dt><dd>
The listener to add </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__signal_1ab0ade7ac929136ad457cc1e0f34f9e10"></a><span class="term">wl_signal_get
            - 
Gets the listener struct for the specified callback.         </span></dt><dd><pre class="synopsis">static struct wl_listener * wl_signal_get(struct wl_signal *signal, wl_notify_func_t notify)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">signal</span></dt><dd>
The signal that contains the specified listener </dd><dt><span class="term">notify</span></dt><dd>
The listener that is the target of this search </dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>the list item that corresponds to the specified listener, or NULL if none was found </dd></dl></div><p>
</p></dd><dt><a name="Server-structwl__signal_1afe73f44f7f1b517c9c0ba90829c93309"></a><span class="term">wl_signal_emit
            - 
Emits this signal, notifying all registered listeners.         </span></dt><dd><pre class="synopsis">static void wl_signal_emit(struct wl_signal *signal, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">signal</span></dt><dd>
The signal object that will emit the signal </dd><dt><span class="term">data</span></dt><dd>
The data that will be emitted with the signal </dd></dl></div><p>
</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-structwl__socket"></a>wl_socket</h2></div></div></div><p></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Server-Functions"></a>Functions</h2></div></div></div><p></p><div class="variablelist"><dl class="variablelist"><dt><a name="Server-wayland-server-core_8h_1af1e9ad8dd32ea89265936930cd173ec5"></a><span class="term">wl_client_for_each
            - 
Iterate over a list of clients.         </span></dt><dd><pre class="synopsis"></pre></dd><dt><a name="Server-wayland-server-core_8h_1a869353bf26daf40e7317cd00473f8dcd"></a><span class="term">wl_display_global_filter_func_t
            - 
A filter function for wl_global objects.         </span></dt><dd><pre class="synopsis">typedef bool(* wl_display_global_filter_func_t) (const struct wl_client *client, const struct wl_global *global, void *data))(const struct wl_client *client, const struct wl_global *global, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">client</span></dt><dd>
The client object </dd><dt><span class="term">global</span></dt><dd>
The global object to show or hide </dd><dt><span class="term">data</span></dt><dd>
The user data pointer</dd></dl></div><p>
A filter function enables the server to decide which globals to advertise to each client.</p><p>When a <a class="link" href="apc.html#Server-structwl__global" title="wl_global">wl_global</a> filter is set, the given callback funtion will be called during <a class="link" href="apc.html#Server-structwl__global" title="wl_global">wl_global</a> advertisment and binding.</p><p>This function should return true if the global object should be made visible to the client or false otherwise. </p></dd><dt><a name="Server-wayland-server-core_8h_1adf933ad178be05536668da731acc6871"></a><span class="term">wl_event_loop_create</span></dt><dd><pre class="synopsis">struct wl_event_loop* wl_event_loop_create(void)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ad50f13e2c738e68f7576757aa862513a"></a><span class="term">wl_event_loop_destroy</span></dt><dd><pre class="synopsis">void wl_event_loop_destroy(struct wl_event_loop *loop)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a677f7df496a70388151e56a88c46ad36"></a><span class="term">wl_event_loop_add_fd</span></dt><dd><pre class="synopsis">struct wl_event_source* wl_event_loop_add_fd(struct wl_event_loop *loop, int fd, uint32_t mask, wl_event_loop_fd_func_t func, void *data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1afe73f9ff59d489e9f27eb9c0e3058a02"></a><span class="term">wl_event_source_fd_update</span></dt><dd><pre class="synopsis">int wl_event_source_fd_update(struct wl_event_source *source, uint32_t mask)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a2881e5ca8c07dea463fbd526b6506f7f"></a><span class="term">wl_event_loop_add_timer</span></dt><dd><pre class="synopsis">struct wl_event_source* wl_event_loop_add_timer(struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void *data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a0baa596851764fb5a91da83642777000"></a><span class="term">wl_event_loop_add_signal</span></dt><dd><pre class="synopsis">struct wl_event_source* wl_event_loop_add_signal(struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void *data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a0164a47e9e8356af90c9d5c1de9f5487"></a><span class="term">wl_event_source_timer_update</span></dt><dd><pre class="synopsis">int wl_event_source_timer_update(struct wl_event_source *source, int ms_delay)</pre></dd><dt><a name="Server-wayland-server-core_8h_1afe37015d67b81ae82609f2b8aa78cc4f"></a><span class="term">wl_event_source_remove</span></dt><dd><pre class="synopsis">int wl_event_source_remove(struct wl_event_source *source)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aa079264c57dd12168c691c000724efcf"></a><span class="term">wl_event_source_check</span></dt><dd><pre class="synopsis">void wl_event_source_check(struct wl_event_source *source)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aaa3fdd5590365a4a2106c9814ca9b31b"></a><span class="term">wl_event_loop_dispatch</span></dt><dd><pre class="synopsis">int wl_event_loop_dispatch(struct wl_event_loop *loop, int timeout)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aefc44b3062c22d2506ff42460f091396"></a><span class="term">wl_event_loop_dispatch_idle</span></dt><dd><pre class="synopsis">void wl_event_loop_dispatch_idle(struct wl_event_loop *loop)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a2a1b5d6c1947954b0f74cfeb5f067b76"></a><span class="term">wl_event_loop_add_idle</span></dt><dd><pre class="synopsis">struct wl_event_source* wl_event_loop_add_idle(struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void *data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a58c8aa06a2d240a49a95a91eddcba8e5"></a><span class="term">wl_event_loop_get_fd</span></dt><dd><pre class="synopsis">int wl_event_loop_get_fd(struct wl_event_loop *loop)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a6b564d8d4183d71f1fdf06e751d84d51"></a><span class="term">wl_event_loop_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_event_loop_add_destroy_listener(struct wl_event_loop *loop, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a2b199278145924742fd2672755d6f8e0"></a><span class="term">wl_event_loop_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_event_loop_get_destroy_listener(struct wl_event_loop *loop, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a496bcdc506013f5fd47641777deb9618"></a><span class="term">wl_display_create</span></dt><dd><pre class="synopsis">struct wl_display* wl_display_create(void)</pre></dd><dt><a name="Server-wayland-server-core_8h_1acd9ad2e1ca3ffb0ba0f1b77ae616f8ee"></a><span class="term">wl_display_destroy</span></dt><dd><pre class="synopsis">void wl_display_destroy(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1afe7a4b1d6fbf166a66f686c830e2946c"></a><span class="term">wl_display_get_event_loop</span></dt><dd><pre class="synopsis">struct wl_event_loop* wl_display_get_event_loop(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a9fdf7264f0a3a28a75c141db252067b8"></a><span class="term">wl_display_add_socket</span></dt><dd><pre class="synopsis">int wl_display_add_socket(struct wl_display *display, const char *name)</pre></dd><dt><a name="Server-wayland-server-core_8h_1af867e52066bc5fff5bb0c1d971735f8f"></a><span class="term">wl_display_add_socket_auto</span></dt><dd><pre class="synopsis">const char* wl_display_add_socket_auto(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a54f1cf58cc74cd44c889b2cdf029345d"></a><span class="term">wl_display_add_socket_fd</span></dt><dd><pre class="synopsis">int wl_display_add_socket_fd(struct wl_display *display, int sock_fd)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a40e3041d2432d3941b3e8eb96c5284dc"></a><span class="term">wl_display_terminate</span></dt><dd><pre class="synopsis">void wl_display_terminate(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a999da1b9acb5808a3bbad60aaed8a7ff"></a><span class="term">wl_display_run</span></dt><dd><pre class="synopsis">void wl_display_run(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aeb502f6fdde16d9ee08f31aed040355f"></a><span class="term">wl_display_flush_clients</span></dt><dd><pre class="synopsis">void wl_display_flush_clients(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ab50365739904f91579a66f4b054a3ecb"></a><span class="term">wl_display_destroy_clients</span></dt><dd><pre class="synopsis">void wl_display_destroy_clients(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a43f04f76ea1457edcf37c95de68b29ef"></a><span class="term">wl_display_get_serial</span></dt><dd><pre class="synopsis">uint32_t wl_display_get_serial(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a145f7d3e4b41fc9014c11bf01bd7eb4f"></a><span class="term">wl_display_next_serial</span></dt><dd><pre class="synopsis">uint32_t wl_display_next_serial(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a9ea24547f07538f2a326c42c7793b937"></a><span class="term">wl_display_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_display_add_destroy_listener(struct wl_display *display, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a8c1cdf513c91fa498c4d9259eae3ed71"></a><span class="term">wl_display_add_client_created_listener
            - 
Registers a listener for the client connection signal.         </span></dt><dd><pre class="synopsis">void wl_display_add_client_created_listener(struct wl_display *display, struct wl_listener *listener)</pre><p>When a new client object is created, listener will be notified, carrying a pointer to the new <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a> object.</p><p><a class="link" href="apc.html#Server-structwl__display_1aa2436b6a0b56cd65d8f6e33b76cd292c">wl_client_create</a> <a class="link" href="apc.html#Server-structwl__display" title="wl_display">wl_display</a> <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a></p><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object </dd><dt><span class="term">listener</span></dt><dd>
Signal handler object </dd></dl></div><p>
</p></dd><dt><a name="Server-wayland-server-core_8h_1ad2e481a3157b1d182bb665a145230ae9"></a><span class="term">wl_display_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_display_get_destroy_listener(struct wl_display *display, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a85f5bc1c041738f5663835c5565ce0b8"></a><span class="term">wl_global_create</span></dt><dd><pre class="synopsis">struct wl_global* wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a7f93649ba31c12220ee77982a37aa270"></a><span class="term">wl_global_remove
            - 
Remove the global.         </span></dt><dd><pre class="synopsis">void wl_global_remove(struct wl_global *global)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">global</span></dt><dd>
The Wayland global.</dd></dl></div><p>
Broadcast a global remove event to all clients without destroying the global. This function can only be called once per global.</p><p><a class="link" href="apc.html#Server-wayland-server_8c_1ab466d94d1f204fb5f07c57e5f558ab7a">wl_global_destroy()</a> removes the global and immediately destroys it. On the other end, this function only removes the global, allowing clients that have not yet received the global remove event to continue to bind to it.</p><p>This can be used by compositors to mitigate clients being disconnected because a global has been added and removed too quickly. Compositors can call <a class="link" href="apc.html#Server-wayland-server_8c_1a7f93649ba31c12220ee77982a37aa270">wl_global_remove()</a>, then wait an implementation-defined amount of time, then call <a class="link" href="apc.html#Server-wayland-server_8c_1ab466d94d1f204fb5f07c57e5f558ab7a">wl_global_destroy()</a>. Note that the destruction of a global is still racy, since clients have no way to acknowledge that they received the remove event.</p><p>
  Since: 1.17.90 
</p></dd><dt><a name="Server-wayland-server-core_8h_1ab466d94d1f204fb5f07c57e5f558ab7a"></a><span class="term">wl_global_destroy</span></dt><dd><pre class="synopsis">void wl_global_destroy(struct wl_global *global)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a3905b9734d8bb84f2c851bb4abbc52f8"></a><span class="term">wl_display_set_global_filter</span></dt><dd><pre class="synopsis">void wl_display_set_global_filter(struct wl_display *display, wl_display_global_filter_func_t filter, void *data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a82c2f11ffbb50bdb57e07e275b2362e6"></a><span class="term">wl_global_get_interface</span></dt><dd><pre class="synopsis">const struct wl_interface* wl_global_get_interface(const struct wl_global *global)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ac8aa5d6a692cd28378c051b6a35c41da"></a><span class="term">wl_global_get_user_data</span></dt><dd><pre class="synopsis">void* wl_global_get_user_data(const struct wl_global *global)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aad255def9cc20dde8150bb4902c40125"></a><span class="term">wl_global_set_user_data
            - 
Set the global's user data.         </span></dt><dd><pre class="synopsis">void wl_global_set_user_data(struct wl_global *global, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">global</span></dt><dd>
The global object </dd><dt><span class="term">data</span></dt><dd>
The user data pointer</dd></dl></div><p>

  Since: 1.17.90 
</p></dd><dt><a name="Server-wayland-server-core_8h_1afb954d2c512f4d0140e25cd331c2cd9f"></a><span class="term">wl_client_create</span></dt><dd><pre class="synopsis">struct wl_client* wl_client_create(struct wl_display *display, int fd)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aa3a43d9b00d83d21af1274e186d7cd1d"></a><span class="term">wl_display_get_client_list</span></dt><dd><pre class="synopsis">struct wl_list* wl_display_get_client_list(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a495543089904236f253c1f0095f942a1"></a><span class="term">wl_client_get_link</span></dt><dd><pre class="synopsis">struct wl_list* wl_client_get_link(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aee7e1851a470ebe47651db71bf24682d"></a><span class="term">wl_client_from_link</span></dt><dd><pre class="synopsis">struct wl_client* wl_client_from_link(struct wl_list *link)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a661c0b1a9deef909c5d43f5efe4cb524"></a><span class="term">wl_client_destroy</span></dt><dd><pre class="synopsis">void wl_client_destroy(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a6a045ad15d6ca216c4da41ba67c9ef4a"></a><span class="term">wl_client_flush</span></dt><dd><pre class="synopsis">void wl_client_flush(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a82a97cb3a66c1c56826a09a7b42453d9"></a><span class="term">wl_client_get_credentials</span></dt><dd><pre class="synopsis">void wl_client_get_credentials(struct wl_client *client, pid_t *pid, uid_t *uid, gid_t *gid)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ad5a94921b39efad0985632e865479ca2"></a><span class="term">wl_client_get_fd</span></dt><dd><pre class="synopsis">int wl_client_get_fd(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a9062fe6277721ec5b4b7d3cec9e34981"></a><span class="term">wl_client_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_client_add_destroy_listener(struct wl_client *client, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a6f20471027c1fe02e79af96426ef5bf4"></a><span class="term">wl_client_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_client_get_destroy_listener(struct wl_client *client, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aa589ab039ac7e67a9da5ccdada9fcb4c"></a><span class="term">wl_client_get_object</span></dt><dd><pre class="synopsis">struct wl_resource* wl_client_get_object(struct wl_client *client, uint32_t id)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a12352da895372907cf30449435d8ee5f"></a><span class="term">wl_client_post_no_memory</span></dt><dd><pre class="synopsis">void wl_client_post_no_memory(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a04fcd7870e530b4f63e45851bc3df9c4"></a><span class="term">wl_client_post_implementation_error</span></dt><dd><pre class="synopsis">void wl_client_post_implementation_error(struct wl_client *client, const char *msg,...)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a62a52be27947e43ce7884a68759d1b4e"></a><span class="term">wl_client_add_resource_created_listener</span></dt><dd><pre class="synopsis">void wl_client_add_resource_created_listener(struct wl_client *client, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a4a0a6bb48f63ed80ab4575fda4c5d01a"></a><span class="term">wl_client_for_each_resource</span></dt><dd><pre class="synopsis">void wl_client_for_each_resource(struct wl_client *client, wl_client_for_each_resource_iterator_func_t iterator, void *user_data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a67150e8e41fed1358dfd59d46fcda23b"></a><span class="term">wl_resource_post_event</span></dt><dd><pre class="synopsis">void wl_resource_post_event(struct wl_resource *resource, uint32_t opcode,...)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a97deed922e68853cb3785947926d56a7"></a><span class="term">wl_resource_post_event_array</span></dt><dd><pre class="synopsis">void wl_resource_post_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a67891685eff3a9ebd5371d78ca83d516"></a><span class="term">wl_resource_queue_event</span></dt><dd><pre class="synopsis">void wl_resource_queue_event(struct wl_resource *resource, uint32_t opcode,...)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a9b63bd8423712f6edebfd6dae9e48225"></a><span class="term">wl_resource_queue_event_array</span></dt><dd><pre class="synopsis">void wl_resource_queue_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a75428b89fa7e6aa97027bb74b348c386"></a><span class="term">wl_resource_post_error</span></dt><dd><pre class="synopsis">void wl_resource_post_error(struct wl_resource *resource, uint32_t code, const char *msg,...)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aefff369c8182adc3c29ea561e23b9fd8"></a><span class="term">wl_resource_post_no_memory</span></dt><dd><pre class="synopsis">void wl_resource_post_no_memory(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a1a69200af1f06ccbcd218b2328f3c885"></a><span class="term">wl_client_get_display</span></dt><dd><pre class="synopsis">struct wl_display* wl_client_get_display(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a26b54247cd0b84c9e228e2a2f9227f8c"></a><span class="term">wl_resource_create</span></dt><dd><pre class="synopsis">struct wl_resource* wl_resource_create(struct wl_client *client, const struct wl_interface *interface, int version, uint32_t id)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a9ac84b9077dcf2020f2b847189d4ebc0"></a><span class="term">wl_resource_set_implementation</span></dt><dd><pre class="synopsis">void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a6d127d9e4489ae795850a9b32d8c5637"></a><span class="term">wl_resource_set_dispatcher</span></dt><dd><pre class="synopsis">void wl_resource_set_dispatcher(struct wl_resource *resource, wl_dispatcher_func_t dispatcher, const void *implementation, void *data, wl_resource_destroy_func_t destroy)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a4fd83132742252516c9a3df7f4eaa4d7"></a><span class="term">wl_resource_destroy</span></dt><dd><pre class="synopsis">void wl_resource_destroy(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ae265d2902bc8e0994b26a3f43e63448c"></a><span class="term">wl_resource_get_id</span></dt><dd><pre class="synopsis">uint32_t wl_resource_get_id(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ab1de3c23a75ddb99ff8c29c0e759a39b"></a><span class="term">wl_resource_get_link</span></dt><dd><pre class="synopsis">struct wl_list* wl_resource_get_link(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a6ed2f937f570b36e7842c5a0bd3d754b"></a><span class="term">wl_resource_from_link</span></dt><dd><pre class="synopsis">struct wl_resource* wl_resource_from_link(struct wl_list *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a4ac3fbd1d228f441c6846f3ebccc9c6e"></a><span class="term">wl_resource_find_for_client</span></dt><dd><pre class="synopsis">struct wl_resource* wl_resource_find_for_client(struct wl_list *list, struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a300147832089811f11d345fbc3f47fe6"></a><span class="term">wl_resource_get_client</span></dt><dd><pre class="synopsis">struct wl_client* wl_resource_get_client(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aa9b40199dbf513b6a25263872b8490c6"></a><span class="term">wl_resource_set_user_data</span></dt><dd><pre class="synopsis">void wl_resource_set_user_data(struct wl_resource *resource, void *data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a07f2328aa269ff1968afc4836018204f"></a><span class="term">wl_resource_get_user_data</span></dt><dd><pre class="synopsis">void* wl_resource_get_user_data(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a8f0f7d0b0f0fb9f44ccd3694b3dd58d5"></a><span class="term">wl_resource_get_version</span></dt><dd><pre class="synopsis">int wl_resource_get_version(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ab69024ab2f0f502aa70cf18bb2761882"></a><span class="term">wl_resource_set_destructor</span></dt><dd><pre class="synopsis">void wl_resource_set_destructor(struct wl_resource *resource, wl_resource_destroy_func_t destroy)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a8849a58c3ba7a528c643591369125844"></a><span class="term">wl_resource_instance_of</span></dt><dd><pre class="synopsis">int wl_resource_instance_of(struct wl_resource *resource, const struct wl_interface *interface, const void *implementation)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ae570127d26c63db09db82afa3a8cda2d"></a><span class="term">wl_resource_get_class</span></dt><dd><pre class="synopsis">const char* wl_resource_get_class(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a6eac87009589e0bdc52830833ca46694"></a><span class="term">wl_resource_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_resource_add_destroy_listener(struct wl_resource *resource, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a46364ef94b5671f41f4cb9587070b23f"></a><span class="term">wl_resource_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_resource_get_destroy_listener(struct wl_resource *resource, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a55964fd7a5774ed9f94bfadce6f8a8ce"></a><span class="term">wl_shm_buffer_get</span></dt><dd><pre class="synopsis">struct wl_shm_buffer* wl_shm_buffer_get(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a809cb5d6b33338c62bbca6daa4138667"></a><span class="term">wl_shm_buffer_begin_access</span></dt><dd><pre class="synopsis">void wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a030db6056ef08836e9dee21a8087e2c1"></a><span class="term">wl_shm_buffer_end_access</span></dt><dd><pre class="synopsis">void wl_shm_buffer_end_access(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1adeb4b01f2ecca2cbd9002d6d64f16ac4"></a><span class="term">wl_shm_buffer_get_data</span></dt><dd><pre class="synopsis">void* wl_shm_buffer_get_data(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ad132f92b616451c67aeb6a25cc60f282"></a><span class="term">wl_shm_buffer_get_stride</span></dt><dd><pre class="synopsis">int32_t wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1af27bd34e94cc995f25a08a0beadd8bc9"></a><span class="term">wl_shm_buffer_get_format</span></dt><dd><pre class="synopsis">uint32_t wl_shm_buffer_get_format(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ada7167ed92985de64ff9116b09a07708"></a><span class="term">wl_shm_buffer_get_width</span></dt><dd><pre class="synopsis">int32_t wl_shm_buffer_get_width(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1acd6812b7699de5a1b80eb4bf1c78aa0e"></a><span class="term">wl_shm_buffer_get_height</span></dt><dd><pre class="synopsis">int32_t wl_shm_buffer_get_height(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ae4dc5539543e07f3c9b9b69f0566d53f"></a><span class="term">wl_shm_buffer_ref_pool</span></dt><dd><pre class="synopsis">struct wl_shm_pool* wl_shm_buffer_ref_pool(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a2349156a6b7940645a4754e6c1690051"></a><span class="term">wl_shm_pool_unref</span></dt><dd><pre class="synopsis">void wl_shm_pool_unref(struct wl_shm_pool *pool)</pre></dd><dt><a name="Server-wayland-server-core_8h_1aef08c24892f8fa98431e0610ee487ef7"></a><span class="term">wl_display_init_shm</span></dt><dd><pre class="synopsis">int wl_display_init_shm(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a17e2cee84d163f938f8906b6f9a5089e"></a><span class="term">wl_display_add_shm_format</span></dt><dd><pre class="synopsis">uint32_t* wl_display_add_shm_format(struct wl_display *display, uint32_t format)</pre></dd><dt><a name="Server-wayland-server-core_8h_1a2c1c1d3e116c9491e1e66525e74a85bb"></a><span class="term">wl_shm_buffer_create</span></dt><dd><pre class="synopsis">struct wl_shm_buffer* wl_shm_buffer_create(struct wl_client *client, uint32_t id, int32_t width, int32_t height, int32_t stride, uint32_t format) WL_DEPRECATED</pre></dd><dt><a name="Server-wayland-server-core_8h_1a0a0e1384dce2524161299fcd1669d59f"></a><span class="term">wl_log_set_handler_server</span></dt><dd><pre class="synopsis">void wl_log_set_handler_server(wl_log_func_t handler)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ad50c4a699b66a468825fd14d09a9c864"></a><span class="term">wl_display_add_protocol_logger</span></dt><dd><pre class="synopsis">struct wl_protocol_logger* wl_display_add_protocol_logger(struct wl_display *display, wl_protocol_logger_func_t, void *user_data)</pre></dd><dt><a name="Server-wayland-server-core_8h_1ac5bfbf098cbecb788190bc12e3becad7"></a><span class="term">wl_protocol_logger_destroy</span></dt><dd><pre class="synopsis">void wl_protocol_logger_destroy(struct wl_protocol_logger *logger)</pre></dd><dt><a name="Server-wayland-server_8c_1a97deed922e68853cb3785947926d56a7"></a><span class="term">wl_resource_post_event_array</span></dt><dd><pre class="synopsis">void wl_resource_post_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)</pre></dd><dt><a name="Server-wayland-server_8c_1a67150e8e41fed1358dfd59d46fcda23b"></a><span class="term">wl_resource_post_event</span></dt><dd><pre class="synopsis">void wl_resource_post_event(struct wl_resource *resource, uint32_t opcode,...)</pre></dd><dt><a name="Server-wayland-server_8c_1a9b63bd8423712f6edebfd6dae9e48225"></a><span class="term">wl_resource_queue_event_array</span></dt><dd><pre class="synopsis">void wl_resource_queue_event_array(struct wl_resource *resource, uint32_t opcode, union wl_argument *args)</pre></dd><dt><a name="Server-wayland-server_8c_1a67891685eff3a9ebd5371d78ca83d516"></a><span class="term">wl_resource_queue_event</span></dt><dd><pre class="synopsis">void wl_resource_queue_event(struct wl_resource *resource, uint32_t opcode,...)</pre></dd><dt><a name="Server-wayland-server_8c_1a75428b89fa7e6aa97027bb74b348c386"></a><span class="term">wl_resource_post_error</span></dt><dd><pre class="synopsis">void wl_resource_post_error(struct wl_resource *resource, uint32_t code, const char *msg,...)</pre></dd><dt><a name="Server-wayland-server_8c_1a12352da895372907cf30449435d8ee5f"></a><span class="term">wl_client_post_no_memory</span></dt><dd><pre class="synopsis">void wl_client_post_no_memory(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server_8c_1aefff369c8182adc3c29ea561e23b9fd8"></a><span class="term">wl_resource_post_no_memory</span></dt><dd><pre class="synopsis">void wl_resource_post_no_memory(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1a4fd83132742252516c9a3df7f4eaa4d7"></a><span class="term">wl_resource_destroy</span></dt><dd><pre class="synopsis">void wl_resource_destroy(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1ae265d2902bc8e0994b26a3f43e63448c"></a><span class="term">wl_resource_get_id</span></dt><dd><pre class="synopsis">uint32_t wl_resource_get_id(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1ab1de3c23a75ddb99ff8c29c0e759a39b"></a><span class="term">wl_resource_get_link</span></dt><dd><pre class="synopsis">struct wl_list* wl_resource_get_link(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1a9851271c75c89ed572987126278834d9"></a><span class="term">wl_resource_from_link</span></dt><dd><pre class="synopsis">struct wl_resource* wl_resource_from_link(struct wl_list *link)</pre></dd><dt><a name="Server-wayland-server_8c_1a4ac3fbd1d228f441c6846f3ebccc9c6e"></a><span class="term">wl_resource_find_for_client</span></dt><dd><pre class="synopsis">struct wl_resource* wl_resource_find_for_client(struct wl_list *list, struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server_8c_1a300147832089811f11d345fbc3f47fe6"></a><span class="term">wl_resource_get_client</span></dt><dd><pre class="synopsis">struct wl_client* wl_resource_get_client(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1aa9b40199dbf513b6a25263872b8490c6"></a><span class="term">wl_resource_set_user_data</span></dt><dd><pre class="synopsis">void wl_resource_set_user_data(struct wl_resource *resource, void *data)</pre></dd><dt><a name="Server-wayland-server_8c_1a07f2328aa269ff1968afc4836018204f"></a><span class="term">wl_resource_get_user_data</span></dt><dd><pre class="synopsis">void* wl_resource_get_user_data(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1a8f0f7d0b0f0fb9f44ccd3694b3dd58d5"></a><span class="term">wl_resource_get_version</span></dt><dd><pre class="synopsis">int wl_resource_get_version(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-server_8c_1ab69024ab2f0f502aa70cf18bb2761882"></a><span class="term">wl_resource_set_destructor</span></dt><dd><pre class="synopsis">void wl_resource_set_destructor(struct wl_resource *resource, wl_resource_destroy_func_t destroy)</pre></dd><dt><a name="Server-wayland-server_8c_1a8849a58c3ba7a528c643591369125844"></a><span class="term">wl_resource_instance_of</span></dt><dd><pre class="synopsis">int wl_resource_instance_of(struct wl_resource *resource, const struct wl_interface *interface, const void *implementation)</pre></dd><dt><a name="Server-wayland-server_8c_1a6eac87009589e0bdc52830833ca46694"></a><span class="term">wl_resource_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_resource_add_destroy_listener(struct wl_resource *resource, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server_8c_1a46364ef94b5671f41f4cb9587070b23f"></a><span class="term">wl_resource_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_resource_get_destroy_listener(struct wl_resource *resource, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server_8c_1a9062fe6277721ec5b4b7d3cec9e34981"></a><span class="term">wl_client_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_client_add_destroy_listener(struct wl_client *client, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server_8c_1a6f20471027c1fe02e79af96426ef5bf4"></a><span class="term">wl_client_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_client_get_destroy_listener(struct wl_client *client, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server_8c_1a661c0b1a9deef909c5d43f5efe4cb524"></a><span class="term">wl_client_destroy</span></dt><dd><pre class="synopsis">void wl_client_destroy(struct wl_client *client)</pre></dd><dt><a name="Server-wayland-server_8c_1a85f5bc1c041738f5663835c5565ce0b8"></a><span class="term">wl_global_create</span></dt><dd><pre class="synopsis">struct wl_global* wl_global_create(struct wl_display *display, const struct wl_interface *interface, int version, void *data, wl_global_bind_func_t bind)</pre></dd><dt><a name="Server-wayland-server_8c_1a7f93649ba31c12220ee77982a37aa270"></a><span class="term">wl_global_remove
            - 
Remove the global.         </span></dt><dd><pre class="synopsis">void wl_global_remove(struct wl_global *global)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">global</span></dt><dd>
The Wayland global.</dd></dl></div><p>
Broadcast a global remove event to all clients without destroying the global. This function can only be called once per global.</p><p><a class="link" href="apc.html#Server-wayland-server_8c_1ab466d94d1f204fb5f07c57e5f558ab7a">wl_global_destroy()</a> removes the global and immediately destroys it. On the other end, this function only removes the global, allowing clients that have not yet received the global remove event to continue to bind to it.</p><p>This can be used by compositors to mitigate clients being disconnected because a global has been added and removed too quickly. Compositors can call <a class="link" href="apc.html#Server-wayland-server_8c_1a7f93649ba31c12220ee77982a37aa270">wl_global_remove()</a>, then wait an implementation-defined amount of time, then call <a class="link" href="apc.html#Server-wayland-server_8c_1ab466d94d1f204fb5f07c57e5f558ab7a">wl_global_destroy()</a>. Note that the destruction of a global is still racy, since clients have no way to acknowledge that they received the remove event.</p><p>
  Since: 1.17.90 
</p></dd><dt><a name="Server-wayland-server_8c_1ab466d94d1f204fb5f07c57e5f558ab7a"></a><span class="term">wl_global_destroy</span></dt><dd><pre class="synopsis">void wl_global_destroy(struct wl_global *global)</pre></dd><dt><a name="Server-wayland-server_8c_1a82c2f11ffbb50bdb57e07e275b2362e6"></a><span class="term">wl_global_get_interface</span></dt><dd><pre class="synopsis">const struct wl_interface* wl_global_get_interface(const struct wl_global *global)</pre></dd><dt><a name="Server-wayland-server_8c_1ac8aa5d6a692cd28378c051b6a35c41da"></a><span class="term">wl_global_get_user_data</span></dt><dd><pre class="synopsis">void* wl_global_get_user_data(const struct wl_global *global)</pre></dd><dt><a name="Server-wayland-server_8c_1aad255def9cc20dde8150bb4902c40125"></a><span class="term">wl_global_set_user_data
            - 
Set the global's user data.         </span></dt><dd><pre class="synopsis">void wl_global_set_user_data(struct wl_global *global, void *data)</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">global</span></dt><dd>
The global object </dd><dt><span class="term">data</span></dt><dd>
The user data pointer</dd></dl></div><p>

  Since: 1.17.90 
</p></dd><dt><a name="Server-wayland-server_8c_1afe7a4b1d6fbf166a66f686c830e2946c"></a><span class="term">wl_display_get_event_loop</span></dt><dd><pre class="synopsis">struct wl_event_loop* wl_display_get_event_loop(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server_8c_1a40e3041d2432d3941b3e8eb96c5284dc"></a><span class="term">wl_display_terminate</span></dt><dd><pre class="synopsis">void wl_display_terminate(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server_8c_1a999da1b9acb5808a3bbad60aaed8a7ff"></a><span class="term">wl_display_run</span></dt><dd><pre class="synopsis">void wl_display_run(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server_8c_1aeb502f6fdde16d9ee08f31aed040355f"></a><span class="term">wl_display_flush_clients</span></dt><dd><pre class="synopsis">void wl_display_flush_clients(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server_8c_1af867e52066bc5fff5bb0c1d971735f8f"></a><span class="term">wl_display_add_socket_auto</span></dt><dd><pre class="synopsis">const char* wl_display_add_socket_auto(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-server_8c_1a9ea24547f07538f2a326c42c7793b937"></a><span class="term">wl_display_add_destroy_listener</span></dt><dd><pre class="synopsis">void wl_display_add_destroy_listener(struct wl_display *display, struct wl_listener *listener)</pre></dd><dt><a name="Server-wayland-server_8c_1a8c1cdf513c91fa498c4d9259eae3ed71"></a><span class="term">wl_display_add_client_created_listener
            - 
Registers a listener for the client connection signal.         </span></dt><dd><pre class="synopsis">void wl_display_add_client_created_listener(struct wl_display *display, struct wl_listener *listener)</pre><p>When a new client object is created, listener will be notified, carrying a pointer to the new <a class="link" href="apc.html#Server-structwl__client" title="wl_client">wl_client</a> object.</p><p><a class="link" href="apc.html#Server-structwl__display_1aa2436b6a0b56cd65d8f6e33b76cd292c">wl_client_create</a> <a class="link" href="apc.html#Server-structwl__display" title="wl_display">wl_display</a> <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a></p><div class="variablelist"><dl class="variablelist"><dt><span class="term">display</span></dt><dd>
The display object </dd><dt><span class="term">listener</span></dt><dd>
Signal handler object </dd></dl></div><p>
</p></dd><dt><a name="Server-wayland-server_8c_1ad2e481a3157b1d182bb665a145230ae9"></a><span class="term">wl_display_get_destroy_listener</span></dt><dd><pre class="synopsis">struct wl_listener* wl_display_get_destroy_listener(struct wl_display *display, wl_notify_func_t notify)</pre></dd><dt><a name="Server-wayland-server_8c_1a9ac84b9077dcf2020f2b847189d4ebc0"></a><span class="term">wl_resource_set_implementation</span></dt><dd><pre class="synopsis">void wl_resource_set_implementation(struct wl_resource *resource, const void *implementation, void *data, wl_resource_destroy_func_t destroy)</pre></dd><dt><a name="Server-wayland-server_8c_1a6d127d9e4489ae795850a9b32d8c5637"></a><span class="term">wl_resource_set_dispatcher</span></dt><dd><pre class="synopsis">void wl_resource_set_dispatcher(struct wl_resource *resource, wl_dispatcher_func_t dispatcher, const void *implementation, void *data, wl_resource_destroy_func_t destroy)</pre></dd><dt><a name="Server-wayland-server_8c_1a0a0e1384dce2524161299fcd1669d59f"></a><span class="term">wl_log_set_handler_server</span></dt><dd><pre class="synopsis">void wl_log_set_handler_server(wl_log_func_t handler)</pre></dd><dt><a name="Server-wayland-server_8h_1a86592c8dfc359094d1cfd8e6abb47cb7"></a><span class="term">wl_client_add_resource</span></dt><dd><pre class="synopsis">uint32_t wl_client_add_resource(struct wl_client *client, struct wl_resource *resource) WL_DEPRECATED</pre></dd><dt><a name="Server-wayland-server_8h_1a8a87f8712025b4d92e5fe718ea9d745d"></a><span class="term">wl_client_add_object</span></dt><dd><pre class="synopsis">struct wl_resource* wl_client_add_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, uint32_t id, void *data) WL_DEPRECATED</pre></dd><dt><a name="Server-wayland-server_8h_1ab9570639a66efe77ae813c7edaf29c21"></a><span class="term">wl_client_new_object</span></dt><dd><pre class="synopsis">struct wl_resource* wl_client_new_object(struct wl_client *client, const struct wl_interface *interface, const void *implementation, void *data) WL_DEPRECATED</pre></dd><dt><a name="Server-wayland-server_8h_1a81dc2de5891114d1ae89449a048f3b6c"></a><span class="term">wl_display_add_global</span></dt><dd><pre class="synopsis">struct wl_global* wl_display_add_global(struct wl_display *display, const struct wl_interface *interface, void *data, wl_global_bind_func_t bind) WL_DEPRECATED</pre></dd><dt><a name="Server-wayland-server_8h_1ab9bbf24496934f296decd98ebf7940b9"></a><span class="term">wl_display_remove_global</span></dt><dd><pre class="synopsis">void wl_display_remove_global(struct wl_display *display, struct wl_global *global) WL_DEPRECATED</pre></dd><dt><a name="Server-wayland-shm_8c_1aef08c24892f8fa98431e0610ee487ef7"></a><span class="term">wl_display_init_shm</span></dt><dd><pre class="synopsis">int wl_display_init_shm(struct wl_display *display)</pre></dd><dt><a name="Server-wayland-shm_8c_1a55964fd7a5774ed9f94bfadce6f8a8ce"></a><span class="term">wl_shm_buffer_get</span></dt><dd><pre class="synopsis">struct wl_shm_buffer* wl_shm_buffer_get(struct wl_resource *resource)</pre></dd><dt><a name="Server-wayland-shm_8c_1ad132f92b616451c67aeb6a25cc60f282"></a><span class="term">wl_shm_buffer_get_stride</span></dt><dd><pre class="synopsis">int32_t wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-shm_8c_1af27bd34e94cc995f25a08a0beadd8bc9"></a><span class="term">wl_shm_buffer_get_format</span></dt><dd><pre class="synopsis">uint32_t wl_shm_buffer_get_format(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-shm_8c_1ada7167ed92985de64ff9116b09a07708"></a><span class="term">wl_shm_buffer_get_width</span></dt><dd><pre class="synopsis">int32_t wl_shm_buffer_get_width(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-shm_8c_1acd6812b7699de5a1b80eb4bf1c78aa0e"></a><span class="term">wl_shm_buffer_get_height</span></dt><dd><pre class="synopsis">int32_t wl_shm_buffer_get_height(struct wl_shm_buffer *buffer)</pre></dd><dt><a name="Server-wayland-util_8h_1a3b28bd92b6af30b28f13c09e45269d5b"></a><span class="term">WL_EXPORT
            - 
Visibility attribute.         </span></dt><dd><pre class="synopsis"></pre></dd><dt><a name="Server-wayland-util_8h_1a9ef5a521a018de9c5b28a5ef9909cd33"></a><span class="term">WL_DEPRECATED
            - 
Deprecated attribute.         </span></dt><dd><pre class="synopsis"></pre></dd><dt><a name="Server-wayland-util_8h_1aa7cbf0ab788d6898c97f322630577424"></a><span class="term">WL_PRINTF
            - 
Printf-style argument attribute.         </span></dt><dd><pre class="synopsis"></pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">x</span></dt><dd>
Ordinality of the format string argument </dd><dt><span class="term">y</span></dt><dd>
Ordinality of the argument to check against the format string</dd></dl></div><p>

  See also: https://gcc.gnu.org/onlinedocs/gcc-3.2.1/gcc/Function-Attributes.html 
</p></dd><dt><a name="Server-wayland-util_8h_1a09e3b64ee2195e1b80191aa1884d45aa"></a><span class="term">wl_container_of
            - 
Retrieves a pointer to a containing struct, given a member name.         </span></dt><dd><pre class="synopsis"></pre><p>This macro allows "conversion" from a pointer to a member to its containing struct. This is useful if you have a contained item like a <a class="link" href="apc.html#Server-structwl__list" title="wl_list - Doubly-linked list.">wl_list</a>, <a class="link" href="apc.html#Server-structwl__listener" title="wl_listener - A single listener for Wayland signals.">wl_listener</a>, or <a class="link" href="apc.html#Server-structwl__signal" title="wl_signal - A source of a type of observable event.">wl_signal</a>, provided via a callback or other means, and would like to retrieve the struct that contains it.</p><p>To demonstrate, the following example retrieves a pointer to example_container given only its destroy_listener member:</p><p>
          </p><pre class="programlisting">struct example_container {
        struct wl_listener destroy_listener;
        // other members...
};

void example_container_destroy(struct wl_listener *listener, void *data)
{
        struct example_container *ctr;

        ctr = wl_container_of(listener, ctr, destroy_listener);
        // destroy ctr...
}
</pre><p>
        </p><p><span class="emphasis"><em>Note: sample need not be a valid pointer. A null or uninitialised pointer is sufficient.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ptr</span></dt><dd>
Valid pointer to the contained member </dd><dt><span class="term">sample</span></dt><dd>
Pointer to a struct whose type contains ptr </dd><dt><span class="term">member</span></dt><dd>
Named location of ptr within the sample type</dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>The container for the specified pointer </dd></dl></div><p>
</p></dd><dt><a name="Server-wayland-util_8h_1adb093d005a4b7e04111b7e385349cf23"></a><span class="term">wl_iterator_result
            - 
Return value of an iterator function.         </span></dt><dd><pre class="synopsis"></pre><p>
  See also: <a class="link" href="">wl_client_for_each_resource_iterator_func_t</a> 

  See also: <a class="link" href="apc.html#Server-structwl__client_1a4a0a6bb48f63ed80ab4575fda4c5d01a">wl_client_for_each_resource</a> 
</p></dd><dt><a name="Server-wayland-util_8h_1a546c8b2b06f97d0617000db4fb4feeeb"></a><span class="term">wl_fixed_t
            - 
Fixed-point number.         </span></dt><dd><pre class="synopsis">typedef int32_t wl_fixed_t</pre><p>A wl_fixed_t is a 24.8 signed fixed-point number with a sign bit, 23 bits of integer precision and 8 bits of decimal precision. Consider wl_fixed_t as an opaque struct with methods that facilitate conversion to and from double and int types. </p></dd><dt><a name="Server-wayland-util_8h_1abdec454d1dffed08d355d225e21ac8bd"></a><span class="term">wl_dispatcher_func_t
            - 
Dispatcher function type alias.         </span></dt><dd><pre class="synopsis">typedef int(* wl_dispatcher_func_t) (const void *, void *, uint32_t, const struct wl_message *, union wl_argument *))(const void *, void *, uint32_t, const struct wl_message *, union wl_argument *)</pre><p>A dispatcher is a function that handles the emitting of callbacks in client code. For programs directly using the C library, this is done by using libffi to call function pointers. When binding to languages other than C, dispatchers provide a way to abstract the function calling process to be friendlier to other function calling systems.</p><p>A dispatcher takes five arguments: The first is the dispatcher-specific implementation associated with the target object. The second is the object upon which the callback is being invoked (either wl_proxy or <a class="link" href="apc.html#Server-structwl__resource" title="wl_resource">wl_resource</a>). The third and fourth arguments are the opcode and the <a class="link" href="apc.html#Server-structwl__message" title="wl_message - Protocol message signature.">wl_message</a> corresponding to the callback. The final argument is an array of arguments received from the other process via the wire protocol.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">const void *</span></dt><dd>
Dispatcher-specific implementation data </dd><dt><span class="term">void *</span></dt><dd>
Callback invocation target (wl_proxy or <a class="link" href="apc.html#Server-structwl__resource" title="wl_resource">wl_resource</a>) </dd><dt><span class="term">uint32_t</span></dt><dd>
Callback opcode </dd><dt><span class="term">const struct wl_message *</span></dt><dd>
Callback message signature </dd><dt><span class="term">union wl_argument *</span></dt><dd>
Array of received arguments</dd></dl></div><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Returns:</span></dt><dd>0 on success, or -1 on failure </dd></dl></div><p>
</p></dd><dt><a name="Server-wayland-util_8h_1a8bbe3cc915acdaf00f7a183bf03d809c"></a><span class="term">wl_log_func_t
            - 
Log function type alias.         </span></dt><dd><pre class="synopsis">typedef void(* wl_log_func_t) (const char *, va_list))(const char *, va_list)</pre><p>The C implementation of the Wayland protocol abstracts the details of logging. Users may customize the logging behavior, with a function conforming to the wl_log_func_t type, via wl_log_set_handler_client and wl_log_set_handler_server.</p><p>A wl_log_func_t must conform to the expectations of vprintf, and expects two arguments: a string to write and a corresponding variable argument list. While the string to write may contain format specifiers and use values in the variable argument list, the behavior of any wl_log_func_t depends on the implementation.</p><p><span class="emphasis"><em>Note: Take care to not confuse this with wl_protocol_logger_func_t, which is a specific server-side logger for requests and events.</em></span>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">const char *</span></dt><dd>
String to write to the log, containing optional format specifiers </dd><dt><span class="term">va_list</span></dt><dd>
Variable argument list</dd></dl></div><p>

  See also: wl_log_set_handler_client 

  See also: <a class="link" href="apc.html#Server-wayland-server-core_8h_1a0a0e1384dce2524161299fcd1669d59f">wl_log_set_handler_server</a> 
</p></dd></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="apb.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">Appendix B. Client API </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
