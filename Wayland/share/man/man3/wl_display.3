.TH "wl_display" 3 "Sat May 23 2020" "Version 1.18.90" "Wayland" \" -*- nroff -*-
.ad l
.nh
.SH NAME
wl_display \- Represents a connection to the compositor and acts as a proxy to the \fBwl_display\fP singleton object\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <wayland\-client\-core\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "struct \fBwl_client\fP * \fBwl_client_create\fP (struct \fBwl_display\fP *display, int fd)"
.br
.ti -1c
.RI "struct \fBwl_display\fP * \fBwl_display_create\fP (void)"
.br
.ti -1c
.RI "void \fBwl_display_destroy\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "void \fBwl_display_set_global_filter\fP (struct \fBwl_display\fP *display, \fBwl_display_global_filter_func_t\fP filter, void *data)"
.br
.ti -1c
.RI "uint32_t \fBwl_display_get_serial\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "uint32_t \fBwl_display_next_serial\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "void \fBwl_display_destroy_clients\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_add_socket_fd\fP (struct \fBwl_display\fP *display, int sock_fd)"
.br
.ti -1c
.RI "int \fBwl_display_add_socket\fP (struct \fBwl_display\fP *display, const char *name)"
.br
.ti -1c
.RI "struct \fBwl_protocol_logger\fP * \fBwl_display_add_protocol_logger\fP (struct \fBwl_display\fP *display, \fBwl_protocol_logger_func_t\fP func, void *user_data)"
.br
.ti -1c
.RI "uint32_t * \fBwl_display_add_shm_format\fP (struct \fBwl_display\fP *display, uint32_t format)"
.br
.ti -1c
.RI "struct \fBwl_list\fP * \fBwl_display_get_client_list\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "struct \fBwl_event_queue\fP * \fBwl_display_create_queue\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "struct \fBwl_display\fP * \fBwl_display_connect_to_fd\fP (int fd)"
.br
.ti -1c
.RI "struct \fBwl_display\fP * \fBwl_display_connect\fP (const char *name)"
.br
.ti -1c
.RI "void \fBwl_display_disconnect\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_get_fd\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_roundtrip_queue\fP (struct \fBwl_display\fP *display, struct \fBwl_event_queue\fP *queue)"
.br
.ti -1c
.RI "int \fBwl_display_roundtrip\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_read_events\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_prepare_read_queue\fP (struct \fBwl_display\fP *display, struct \fBwl_event_queue\fP *queue)"
.br
.ti -1c
.RI "int \fBwl_display_prepare_read\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "void \fBwl_display_cancel_read\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_dispatch_queue\fP (struct \fBwl_display\fP *display, struct \fBwl_event_queue\fP *queue)"
.br
.ti -1c
.RI "int \fBwl_display_dispatch_queue_pending\fP (struct \fBwl_display\fP *display, struct \fBwl_event_queue\fP *queue)"
.br
.ti -1c
.RI "int \fBwl_display_dispatch\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_dispatch_pending\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "int \fBwl_display_get_error\fP (struct \fBwl_display\fP *display)"
.br
.ti -1c
.RI "uint32_t \fBwl_display_get_protocol_error\fP (struct \fBwl_display\fP *display, const struct \fBwl_interface\fP **interface, uint32_t *\fBid\fP)"
.br
.ti -1c
.RI "int \fBwl_display_flush\fP (struct \fBwl_display\fP *display)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "struct \fBwl_event_loop\fP * \fBloop\fP"
.br
.ti -1c
.RI "int \fBrun\fP"
.br
.ti -1c
.RI "uint32_t \fBid\fP"
.br
.ti -1c
.RI "uint32_t \fBserial\fP"
.br
.ti -1c
.RI "struct \fBwl_list\fP \fBregistry_resource_list\fP"
.br
.ti -1c
.RI "struct \fBwl_list\fP \fBglobal_list\fP"
.br
.ti -1c
.RI "struct \fBwl_list\fP \fBsocket_list\fP"
.br
.ti -1c
.RI "struct \fBwl_list\fP \fBclient_list\fP"
.br
.ti -1c
.RI "struct \fBwl_list\fP \fBprotocol_loggers\fP"
.br
.ti -1c
.RI "struct wl_priv_signal \fBdestroy_signal\fP"
.br
.ti -1c
.RI "struct wl_priv_signal \fBcreate_client_signal\fP"
.br
.ti -1c
.RI "struct \fBwl_array\fP \fBadditional_shm_formats\fP"
.br
.ti -1c
.RI "\fBwl_display_global_filter_func_t\fP \fBglobal_filter\fP"
.br
.ti -1c
.RI "void * \fBglobal_filter_data\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Represents a connection to the compositor and acts as a proxy to the \fBwl_display\fP singleton object\&. 

A \fBwl_display\fP object represents a client connection to a Wayland compositor\&. It is created with either \fBwl_display_connect()\fP or \fBwl_display_connect_to_fd()\fP\&. A connection is terminated using \fBwl_display_disconnect()\fP\&.
.PP
A \fBwl_display\fP is also used as the \fBwl_proxy\fP for the \fBwl_display\fP singleton object on the compositor side\&.
.PP
A \fBwl_display\fP object handles all the data sent from and to the compositor\&. When a \fBwl_proxy\fP marshals a request, it will write its wire representation to the display's write buffer\&. The data is sent to the compositor when the client calls \fBwl_display_flush()\fP\&.
.PP
Incoming data is handled in two steps: queueing and dispatching\&. In the queue step, the data coming from the display fd is interpreted and added to a queue\&. On the dispatch step, the handler for the incoming event set by the client on the corresponding \fBwl_proxy\fP is called\&.
.PP
A \fBwl_display\fP has at least one event queue, called the \fIdefault queue\fP\&. Clients can create additional event queues with \fBwl_display_create_queue()\fP and assign \fBwl_proxy\fP's to it\&. Events occurring in a particular proxy are always queued in its assigned queue\&. A client can ensure that a certain assumption, such as holding a lock or running from a given thread, is true when a proxy event handler is called by assigning that proxy to an event queue and making sure that this queue is only dispatched when the assumption holds\&.
.PP
The default queue is dispatched by calling \fBwl_display_dispatch()\fP\&. This will dispatch any events queued on the default queue and attempt to read from the display fd if it's empty\&. Events read are then queued on the appropriate queues according to the proxy assignment\&.
.PP
A user created queue is dispatched with \fBwl_display_dispatch_queue()\fP\&. This function behaves exactly the same as \fBwl_display_dispatch()\fP but it dispatches given queue instead of the default queue\&.
.PP
A real world example of event queue usage is Mesa's implementation of eglSwapBuffers() for the Wayland platform\&. This function might need to block until a frame callback is received, but dispatching the default queue could cause an event handler on the client to start drawing again\&. This problem is solved using another event queue, so that only the events handled by the EGL code are dispatched during the block\&.
.PP
This creates a problem where a thread dispatches a non-default queue, reading all the data from the display fd\&. If the application would call \fIpoll(2)\fP after that it would block, even though there might be events queued on the default queue\&. Those events should be dispatched with \fBwl_display_dispatch_pending()\fP or \fBwl_display_dispatch_queue_pending()\fP before flushing and blocking\&. 
.SH "Member Function Documentation"
.PP 
.SS "struct \fBwl_client\fP * wl_client_create (struct \fBwl_display\fP * display, int fd)"
Create a client for the given file descriptor
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object 
.br
\fIfd\fP The file descriptor for the socket to the client 
.RE
.PP
\fBReturns:\fP
.RS 4
The new client object or NULL on failure\&.
.RE
.PP
Given a file descriptor corresponding to one end of a socket, this function will create a \fBwl_client\fP struct and add the new client to the compositors client list\&. At that point, the client is initialized and ready to run, as if the client had connected to the servers listening socket\&. When the client eventually sends requests to the compositor, the \fBwl_client\fP argument to the request handler will be the \fBwl_client\fP returned from this function\&.
.PP
The other end of the socket can be passed to \fBwl_display_connect_to_fd()\fP on the client side or used with the WAYLAND_SOCKET environment variable on the client side\&.
.PP
Listeners added with \fBwl_display_add_client_created_listener()\fP will be notified by this function after the client is fully constructed\&.
.PP
On failure this function sets errno accordingly and returns NULL\&. 
.SS "struct \fBwl_protocol_logger\fP * wl_display_add_protocol_logger (struct \fBwl_display\fP * display, \fBwl_protocol_logger_func_t\fP func, void * user_data)"
Adds a new protocol logger\&.
.PP
When a new protocol message arrives or is sent from the server all the protocol logger functions will be called, carrying the \fIuser_data\fP pointer, the type of the message (request or event) and the actual message\&. The lifetime of the messages passed to the logger function ends when they return so the messages cannot be stored and accessed later\&.
.PP
\fIerrno\fP is set on error\&.
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object 
.br
\fIfunc\fP The function to call to log a new protocol message 
.br
\fIuser_data\fP The user data pointer to pass to \fIfunc\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The protol logger object on success, NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_protocol_logger_destroy\fP 
.RE
.PP

.SS "uint32_t * wl_display_add_shm_format (struct \fBwl_display\fP * display, uint32_t format)"
Add support for a wl_shm pixel format
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object 
.br
\fIformat\fP The wl_shm pixel format to advertise 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the wl_shm format that was added to the list or NULL if adding it to the list failed\&.
.RE
.PP
Add the specified wl_shm format to the list of formats the wl_shm object advertises when a client binds to it\&. Adding a format to the list means that clients will know that the compositor supports this format and may use it for creating wl_shm buffers\&. The compositor must be able to handle the pixel format when a client requests it\&.
.PP
The compositor by default supports WL_SHM_FORMAT_ARGB8888 and WL_SHM_FORMAT_XRGB8888\&. 
.SS "int wl_display_add_socket (struct \fBwl_display\fP * display, const char * name)"
Add a socket to Wayland display for the clients to connect\&.
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP Wayland display to which the socket should be added\&. 
.br
\fIname\fP Name of the Unix socket\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if success\&. -1 if failed\&.
.RE
.PP
This adds a Unix socket to Wayland display which can be used by clients to connect to Wayland display\&.
.PP
If NULL is passed as name, then it would look for WAYLAND_DISPLAY env variable for the socket name\&. If WAYLAND_DISPLAY is not set, then default wayland-0 is used\&.
.PP
The Unix socket will be created in the directory pointed to by environment variable XDG_RUNTIME_DIR\&. If XDG_RUNTIME_DIR is not set, then this function fails and returns -1\&.
.PP
The length of socket path, i\&.e\&., the path set in XDG_RUNTIME_DIR and the socket name, must not exceed the maximum length of a Unix socket path\&. The function also fails if the user do not have write permission in the XDG_RUNTIME_DIR path or if the socket name is already in use\&. 
.SS "int wl_display_add_socket_fd (struct \fBwl_display\fP * display, int sock_fd)"
Add a socket with an existing fd to Wayland display for the clients to connect\&.
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP Wayland display to which the socket should be added\&. 
.br
\fIsock_fd\fP The existing socket file descriptor to be used 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if success\&. -1 if failed\&.
.RE
.PP
The existing socket fd must already be created, opened, and locked\&. The fd must be properly set to CLOEXEC and bound to a socket file with both bind() and listen() already called\&. 
.SS "void wl_display_cancel_read (struct \fBwl_display\fP * display)"
Cancel read intention on display's fd
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object
.RE
.PP
After a thread successfully called \fBwl_display_prepare_read()\fP it must either call \fBwl_display_read_events()\fP or \fBwl_display_cancel_read()\fP\&. If the threads do not follow this rule it will lead to deadlock\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_prepare_read()\fP, \fBwl_display_read_events()\fP 
.RE
.PP

.SS "struct \fBwl_display\fP * wl_display_connect (const char * name)"
Connect to a Wayland display
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of the Wayland display to connect to 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fBwl_display\fP object or \fCNULL\fP on failure
.RE
.PP
Connect to the Wayland display named \fCname\fP\&. If \fCname\fP is \fCNULL\fP, its value will be replaced with the WAYLAND_DISPLAY environment variable if it is set, otherwise display 'wayland-0' will be used\&.
.PP
If WAYLAND_SOCKET is set, it's interpreted as a file descriptor number referring to an already opened socket\&. In this case, the socket is used as-is and \fCname\fP is ignored\&.
.PP
If \fCname\fP is a relative path, then the socket is opened relative to the XDG_RUNTIME_DIR directory\&.
.PP
If \fCname\fP is an absolute path, then that path is used as-is for the location of the socket at which the Wayland server is listening; no qualification inside XDG_RUNTIME_DIR is attempted\&.
.PP
If \fCname\fP is \fCNULL\fP and the WAYLAND_DISPLAY environment variable is set to an absolute pathname, then that pathname is used as-is for the socket in the same manner as if \fCname\fP held an absolute path\&. Support for absolute paths in \fCname\fP and WAYLAND_DISPLAY is present since Wayland version 1\&.15\&. 
.SS "struct \fBwl_display\fP * wl_display_connect_to_fd (int fd)"
Connect to Wayland display on an already open fd
.PP
\fBParameters:\fP
.RS 4
\fIfd\fP The fd to use for the connection 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fBwl_display\fP object or \fCNULL\fP on failure
.RE
.PP
The \fBwl_display\fP takes ownership of the fd and will close it when the display is destroyed\&. The fd will also be closed in case of failure\&. 
.SS "struct \fBwl_display\fP * wl_display_create (void)"
Create Wayland display object\&.
.PP
\fBReturns:\fP
.RS 4
The Wayland display object\&. Null if failed to create
.RE
.PP
This creates the \fBwl_display\fP object\&. 
.SS "struct \fBwl_event_queue\fP * wl_display_create_queue (struct \fBwl_display\fP * display)"
Create a new event queue for this display
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
A new event queue associated with this display or NULL on failure\&. 
.RE
.PP

.SS "void wl_display_destroy (struct \fBwl_display\fP * display)"
Destroy Wayland display object\&.
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The Wayland display object which should be destroyed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&.
.RE
.PP
This function emits the \fBwl_display\fP destroy signal, releases all the sockets added to this display, free's all the globals associated with this display, free's memory of additional shared memory formats and destroy the display object\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_add_destroy_listener\fP 
.RE
.PP

.SS "void wl_display_destroy_clients (struct \fBwl_display\fP * display)"
Destroy all clients connected to the display
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object
.RE
.PP
This function should be called right before \fBwl_display_destroy()\fP to ensure all client resources are closed properly\&. Destroying a client from within \fBwl_display_destroy_clients()\fP is safe, but creating one will leak resources and raise a warning\&. 
.SS "void wl_display_disconnect (struct \fBwl_display\fP * display)"
Close a connection to a Wayland display
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object
.RE
.PP
Close the connection to \fCdisplay\fP and free all resources associated with it\&. 
.SS "int wl_display_dispatch (struct \fBwl_display\fP * display)"
Process incoming events
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of dispatched events on success or -1 on failure
.RE
.PP
Dispatch events on the default event queue\&.
.PP
If the default event queue is empty, this function blocks until there are events to be read from the display fd\&. Events are read and queued on the appropriate event queues\&. Finally, events on the default event queue are dispatched\&. On failure -1 is returned and errno set appropriately\&.
.PP
In a multi threaded environment, do not manually wait using poll() (or equivalent) before calling this function, as doing so might cause a dead lock\&. If external reliance on poll() (or equivalent) is required, see \fBwl_display_prepare_read_queue()\fP of how to do so\&.
.PP
This function is thread safe as long as it dispatches the right queue on the right thread\&. It is also compatible with the multi thread event reading preparation API (see \fBwl_display_prepare_read_queue()\fP), and uses the equivalent functionality internally\&. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock\&.
.PP
\fBNote:\fP
.RS 4
It is not possible to check if there are events on the queue or not\&. For dispatching default queue events without blocking, see \fBwl_display_dispatch_pending()\fP\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_dispatch_pending()\fP, \fBwl_display_dispatch_queue()\fP, \fBwl_display_read_events()\fP 
.RE
.PP

.SS "int wl_display_dispatch_pending (struct \fBwl_display\fP * display)"
Dispatch default queue events without reading from the display fd
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of dispatched events or -1 on failure
.RE
.PP
This function dispatches events on the main event queue\&. It does not attempt to read the display fd and simply returns zero if the main queue is empty, i\&.e\&., it doesn't block\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_dispatch()\fP, \fBwl_display_dispatch_queue()\fP, \fBwl_display_flush()\fP 
.RE
.PP

.SS "int wl_display_dispatch_queue (struct \fBwl_display\fP * display, struct \fBwl_event_queue\fP * queue)"
Dispatch events in an event queue
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.br
\fIqueue\fP The event queue to dispatch 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of dispatched events on success or -1 on failure
.RE
.PP
Dispatch events on the given event queue\&.
.PP
If the given event queue is empty, this function blocks until there are events to be read from the display fd\&. Events are read and queued on the appropriate event queues\&. Finally, events on given event queue are dispatched\&. On failure -1 is returned and errno set appropriately\&.
.PP
In a multi threaded environment, do not manually wait using poll() (or equivalent) before calling this function, as doing so might cause a dead lock\&. If external reliance on poll() (or equivalent) is required, see \fBwl_display_prepare_read_queue()\fP of how to do so\&.
.PP
This function is thread safe as long as it dispatches the right queue on the right thread\&. It is also compatible with the multi thread event reading preparation API (see \fBwl_display_prepare_read_queue()\fP), and uses the equivalent functionality internally\&. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock\&.
.PP
It can be used as a helper function to ease the procedure of reading and dispatching events\&.
.PP
\fBNote:\fP
.RS 4
Since Wayland 1\&.5 the display has an extra queue for its own events (i\&. e\&. delete_id)\&. This queue is dispatched always, no matter what queue we passed as an argument to this function\&. That means that this function can return non-0 value even when it haven't dispatched any event for the given queue\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_dispatch()\fP, \fBwl_display_dispatch_pending()\fP, \fBwl_display_dispatch_queue_pending()\fP, \fBwl_display_prepare_read_queue()\fP 
.RE
.PP

.SS "int wl_display_dispatch_queue_pending (struct \fBwl_display\fP * display, struct \fBwl_event_queue\fP * queue)"
Dispatch pending events in an event queue
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.br
\fIqueue\fP The event queue to dispatch 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of dispatched events on success or -1 on failure
.RE
.PP
Dispatch all incoming events for objects assigned to the given event queue\&. On failure -1 is returned and errno set appropriately\&. If there are no events queued, this function returns immediately\&.
.PP
\fBSince:\fP
.RS 4
1\&.0\&.2 
.RE
.PP

.SS "int wl_display_flush (struct \fBwl_display\fP * display)"
Send all buffered requests on the display to the server
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of bytes sent on success or -1 on failure
.RE
.PP
Send all buffered data on the client side to the server\&. Clients should always call this function before blocking on input from the display fd\&. On success, the number of bytes sent to the server is returned\&. On failure, this function returns -1 and errno is set appropriately\&.
.PP
\fBwl_display_flush()\fP never blocks\&. It will write as much data as possible, but if all data could not be written, errno will be set to EAGAIN and -1 returned\&. In that case, use poll on the display file descriptor to wait for it to become writable again\&. 
.SS "struct \fBwl_list\fP * wl_display_get_client_list (struct \fBwl_display\fP * display)"
Get the list of currently connected clients
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object
.RE
.PP
This function returns a pointer to the list of clients currently connected to the display\&. You can iterate on the list by using the \fIwl_client_for_each\fP macro\&. The returned value is valid for the lifetime of the \fIdisplay\fP\&. You must not modify the returned list, but only access it\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_client_for_each()\fP 
.PP
\fBwl_client_get_link()\fP 
.PP
\fBwl_client_from_link()\fP 
.RE
.PP

.SS "int wl_display_get_error (struct \fBwl_display\fP * display)"
Retrieve the last error that occurred on a display
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
The last error that occurred on \fCdisplay\fP or 0 if no error occurred
.RE
.PP
Return the last error that occurred on the display\&. This may be an error sent by the server or caused by the local client\&.
.PP
\fBNote:\fP
.RS 4
Errors are \fBfatal\fP\&. If this function returns non-zero the display can no longer be used\&. 
.RE
.PP

.SS "int wl_display_get_fd (struct \fBwl_display\fP * display)"
Get a display context's file descriptor
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
Display object file descriptor
.RE
.PP
Return the file descriptor associated with a display so it can be integrated into the client's main loop\&. 
.SS "uint32_t wl_display_get_protocol_error (struct \fBwl_display\fP * display, const struct \fBwl_interface\fP ** interface, uint32_t * id)"
Retrieves the information about a protocol error:
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The Wayland display 
.br
\fIinterface\fP if not NULL, stores the interface where the error occurred, or NULL, if unknown\&. 
.br
\fIid\fP if not NULL, stores the object id that generated the error, or 0, if the object id is unknown\&. There's no guarantee the object is still valid; the client must know if it deleted the object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The error code as defined in the interface specification\&.
.RE
.PP
.PP
.nf
int err = wl_display_get_error(display);

if (err == EPROTO) {
       code = wl_display_get_protocol_error(display, &interface, &id);
       handle_error(code, interface, id);
}

\&.\&.\&.
.fi
.PP
 
.SS "uint32_t wl_display_get_serial (struct \fBwl_display\fP * display)"
Get the current serial number
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object
.RE
.PP
This function returns the most recent serial number, but does not increment it\&. 
.SS "uint32_t wl_display_next_serial (struct \fBwl_display\fP * display)"
Get the next serial number
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display object
.RE
.PP
This function increments the display serial number and returns the new value\&. 
.SS "int wl_display_prepare_read (struct \fBwl_display\fP * display)"
Prepare to read events from the display's file descriptor
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or -1 if event queue was not empty
.RE
.PP
This function does the same thing as \fBwl_display_prepare_read_queue()\fP with the default queue passed as the queue\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_prepare_read_queue\fP 
.RE
.PP

.SS "int wl_display_prepare_read_queue (struct \fBwl_display\fP * display, struct \fBwl_event_queue\fP * queue)"
Prepare to read events from the display's file descriptor to a queue
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.br
\fIqueue\fP The event queue to use 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or -1 if event queue was not empty
.RE
.PP
This function (or \fBwl_display_prepare_read()\fP) must be called before reading from the file descriptor using \fBwl_display_read_events()\fP\&. Calling \fBwl_display_prepare_read_queue()\fP announces the calling thread's intention to read and ensures that until the thread is ready to read and calls \fBwl_display_read_events()\fP, no other thread will read from the file descriptor\&. This only succeeds if the event queue is empty, and if not -1 is returned and errno set to EAGAIN\&.
.PP
If a thread successfully calls \fBwl_display_prepare_read_queue()\fP, it must either call \fBwl_display_read_events()\fP when it's ready or cancel the read intention by calling \fBwl_display_cancel_read()\fP\&.
.PP
Use this function before polling on the display fd or integrate the fd into a toolkit event loop in a race-free way\&. A correct usage would be (with most error checking left out):
.PP
.PP
.nf
while (wl_display_prepare_read_queue(display, queue) != 0)
        wl_display_dispatch_queue_pending(display, queue);
wl_display_flush(display);

ret = poll(fds, nfds, -1);
if (has_error(ret))
        wl_display_cancel_read(display);
else
        wl_display_read_events(display);

wl_display_dispatch_queue_pending(display, queue);
.fi
.PP
.PP
Here we call \fBwl_display_prepare_read_queue()\fP, which ensures that between returning from that call and eventually calling \fBwl_display_read_events()\fP, no other thread will read from the fd and queue events in our queue\&. If the call to \fBwl_display_prepare_read_queue()\fP fails, we dispatch the pending events and try again until we're successful\&.
.PP
The \fBwl_display_prepare_read_queue()\fP function doesn't acquire exclusive access to the display's fd\&. It only registers that the thread calling this function has intention to read from fd\&. When all registered readers call \fBwl_display_read_events()\fP, only one (at random) eventually reads and queues the events and the others are sleeping meanwhile\&. This way we avoid races and still can read from more threads\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_cancel_read()\fP, \fBwl_display_read_events()\fP, \fBwl_display_prepare_read()\fP 
.RE
.PP

.SS "int wl_display_read_events (struct \fBwl_display\fP * display)"
Read events from display file descriptor
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or -1 on error\&. In case of error errno will be set accordingly
.RE
.PP
Calling this function will result in data available on the display file descriptor being read and read events will be queued on their corresponding event queues\&.
.PP
Before calling this function, depending on what thread it is to be called from, \fBwl_display_prepare_read_queue()\fP or \fBwl_display_prepare_read()\fP needs to be called\&. See \fBwl_display_prepare_read_queue()\fP for more details\&.
.PP
When being called at a point where other threads have been prepared to read (using \fBwl_display_prepare_read_queue()\fP or \fBwl_display_prepare_read()\fP) this function will sleep until all other prepared threads have either been cancelled (using \fBwl_display_cancel_read()\fP) or them self entered this function\&. The last thread that calls this function will then read and queue events on their corresponding event queues, and finally wake up all other \fBwl_display_read_events()\fP calls causing them to return\&.
.PP
If a thread cancels a read preparation when all other threads that have prepared to read has either called \fBwl_display_cancel_read()\fP or \fBwl_display_read_events()\fP, all reader threads will return without having read any data\&.
.PP
To dispatch events that may have been queued, call \fBwl_display_dispatch_pending()\fP or \fBwl_display_dispatch_queue_pending()\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_prepare_read()\fP, \fBwl_display_cancel_read()\fP, \fBwl_display_dispatch_pending()\fP, \fBwl_display_dispatch()\fP 
.RE
.PP

.SS "int wl_display_roundtrip (struct \fBwl_display\fP * display)"
Block until all pending request are processed by the server
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of dispatched events on success or -1 on failure
.RE
.PP
This function blocks until the server has processed all currently issued requests by sending a request to the display server and waiting for a reply before returning\&.
.PP
This function uses \fBwl_display_dispatch_queue()\fP internally\&. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock\&.
.PP
\fBNote:\fP
.RS 4
This function may dispatch other events being received on the default queue\&. 
.RE
.PP

.SS "int wl_display_roundtrip_queue (struct \fBwl_display\fP * display, struct \fBwl_event_queue\fP * queue)"
Block until all pending request are processed by the server
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The display context object 
.br
\fIqueue\fP The queue on which to run the roundtrip 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of dispatched events on success or -1 on failure
.RE
.PP
This function blocks until the server has processed all currently issued requests by sending a request to the display server and waiting for a reply before returning\&.
.PP
This function uses \fBwl_display_dispatch_queue()\fP internally\&. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock\&.
.PP
\fBNote:\fP
.RS 4
This function may dispatch other events being received on the given queue\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBwl_display_roundtrip()\fP 
.RE
.PP

.SS "void wl_display_set_global_filter (struct \fBwl_display\fP * display, \fBwl_display_global_filter_func_t\fP filter, void * data)"
Set a filter function for global objects
.PP
\fBParameters:\fP
.RS 4
\fIdisplay\fP The Wayland display object\&. 
.br
\fIfilter\fP The global filter funtion\&. 
.br
\fIdata\fP User data to be associated with the global filter\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&.
.RE
.PP
Set a filter for the \fBwl_display\fP to advertise or hide global objects to clients\&. The set filter will be used during \fBwl_global\fP advertisment to determine whether a global object should be advertised to a given client, and during \fBwl_global\fP binding to determine whether a given client should be allowed to bind to a global\&.
.PP
Clients that try to bind to a global that was filtered out will have an error raised\&.
.PP
Setting the filter NULL will result in all globals being advertised to all clients\&. The default is no filter\&. 
.SH "Field Documentation"
.PP 
.SS "struct \fBwl_array\fP wl_display::additional_shm_formats"

.SS "struct \fBwl_list\fP wl_display::client_list"

.SS "struct wl_priv_signal wl_display::create_client_signal"

.SS "struct wl_priv_signal wl_display::destroy_signal"

.SS "\fBwl_display_global_filter_func_t\fP wl_display::global_filter"

.SS "void* wl_display::global_filter_data"

.SS "struct \fBwl_list\fP wl_display::global_list"

.SS "uint32_t wl_display::id"

.SS "struct \fBwl_event_loop\fP* wl_display::loop"

.SS "struct \fBwl_list\fP wl_display::protocol_loggers"

.SS "struct \fBwl_list\fP wl_display::registry_resource_list"

.SS "int wl_display::run"

.SS "uint32_t wl_display::serial"

.SS "struct \fBwl_list\fP wl_display::socket_list"


.SH "Author"
.PP 
Generated automatically by Doxygen for Wayland from the source code\&.
